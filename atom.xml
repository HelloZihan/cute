<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>记录</title>
  <icon>https://www.gravatar.com/avatar/99bc014e5a3fdf094aa9e60b83adc05e</icon>
  <subtitle>我本可以</subtitle>
  <link href="http://zhaojun.me/atom.xml" rel="self"/>
  
  <link href="http://zhaojun.me/"/>
  <updated>2019-09-08T07:15:35.000Z</updated>
  <id>http://zhaojun.me/</id>
  
  <author>
    <name>zj</name>
    <email>565405576@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CAS及Java原子类</title>
    <link href="http://zhaojun.me/2019/09/02/Java-CAS/"/>
    <id>http://zhaojun.me/2019/09/02/Java-CAS/</id>
    <published>2019-09-02T06:51:35.000Z</published>
    <updated>2019-09-08T07:15:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h3><p>CAS即Compare And Swap的缩写，翻译成中文就是比较并交换，其作用是让CPU比较内存中某个值是否和预期的值相同，如果相同则将这个值更新为新值，不相同则不做更新，也就是CAS是原子性的操作(读和写两者同时具有原子性)，其实现方式是通过借助C/C++调用CPU指令完成的，所以效率很高。</p><ul><li>CAS(compare and swap) 比较并替换，比较和替换是线程并发算法时用到的一种技术</li><li>CAS是原子操作，保证并发安全，而不是保证并发同步</li><li>CAS是CPU的一个指令</li><li>CAS是非阻塞的、轻量级的乐观锁<h3 id="为什么说CAS是乐观锁"><a href="#为什么说CAS是乐观锁" class="headerlink" title="为什么说CAS是乐观锁"></a>为什么说CAS是乐观锁</h3>乐观锁，严格来说并不是锁，通过原子性来保证数据的同步，比如说数据库的乐观锁，通过版本控制来实现等，所以CAS不会保证线程同步。乐观的认为在数据更新期间没有其他线程影响<h3 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h3>CAS(compare and swap)比较并替换，就是将内存值更新为需要的值，但是有个条件，内存值必须与期望值相同。举个例子，期望值 E、内存值M、更新值U，当E==M的时候将M更新为U。<h3 id="CAS应用"><a href="#CAS应用" class="headerlink" title="CAS应用"></a>CAS应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法功能是Interger类型加1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//主要看这个getAndAddInt方法</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//var1 是this指针</span></span><br><span class="line"><span class="comment">//var2 是地址偏移量</span></span><br><span class="line"><span class="comment">//var4 是自增的数值，是自增1还是自增N</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//获取内存值，这是内存值已经是旧的，假设我们称作期望值E</span></span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        <span class="comment">//compareAndSwapInt方法是重点，</span></span><br><span class="line">        <span class="comment">//var5是期望值，var5 + var4是要更新的值</span></span><br><span class="line">        <span class="comment">//这个操作就是调用CAS的JNI,每个线程将自己内存里的内存值M</span></span><br><span class="line">        <span class="comment">//与var5期望值E作比较，如果相同将内存值M更新为var5 + var4,否则做自旋操作</span></span><br><span class="line">        <span class="comment">//compareAndSwapInt 比较and交换是原子操作，但是前面的 getIntVolatile不是原子操作，故需要一个循环</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>解释一下getAndAddInt方法的流程,假设有以下情景：  </li></ul><ol><li>A、B两个线程  </li><li>jvm主内存的值1，A、B工作内存的值为1（工作内存会拷贝一份主内存的值）   </li><li>当前期望值为1，做加1操作  </li><li>此时var5 = 1, var4 = 1<br>（1）A线程将var5与工作内存值M比较，比较var5是否等于1<br>（2）如果相同则将工作内存值修改为var5+var4 既修改为2并同步到主内存，此时this指针里，示例变量value的值就是2，结束循环<br>（3）如果不相同则是B线程修改了主内存的值，说明B线程已经先于A线程做了加1操作，A线程没有更新成功需要继续循环，注意此时var5更新为新的内存值，假设当前的内存值是2，那么此时var5 = 2，var5 + var4 = 3,重复上述步骤直到成功</li></ol><h3 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h3><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>在多线程场景下CAS会出现ABA问题，关于ABA问题这里简单科普下，例如有2个线程同时对同一个值(初始值为A)进行CAS操作，这三个线程如下</p><ul><li>线程1，期望值为A，欲更新的值为B  </li><li>线程2，期望值为A，欲更新的值为B</li></ul><p>线程1抢先获得CPU时间片，而线程2因为其他原因阻塞了，线程1取值与期望的A值比较，发现相等然后将值更新为B，然后这个时候出现了线程3，期望值为B，欲更新的值为A，线程3取值与期望的值B比较，发现相等则将值更新为A，此时线程2从阻塞中恢复，并且获得了CPU时间片，这时候线程2取值与期望的值A比较，发现相等则将值更新为B，虽然线程2也完成了操作，但是线程2并不知道值已经经过了A-&gt;B-&gt;A的变化过程。(此A已经不是当初所想的A了)</p><h5 id="ABA问题带来的危害："><a href="#ABA问题带来的危害：" class="headerlink" title="ABA问题带来的危害："></a>ABA问题带来的危害：</h5><p>小明银行卡有100元，想提取了50元，因为提款机问题，有两个线程，同时会把余额从100变为50<br>线程1（提款机）：获取当前值100，期望更新为50，<br>线程2（提款机）：获取当前值100，期望更新为50，  </p><p>线程1成功执行(此时银行卡只剩50了)，线程2某种原因block了，这时，某人给小明汇款50  </p><p>突然有人给小明汇款50，则有线程3，获取当前值50，期望更新为100，执行完毕，余额变为100</p><p>线程2从Block中恢复，获取到的也是100，compare之后，继续更新余额为50了。</p><p>此时可以看到，正确的余额应该是100，但是实际上变为了50，这就是ABA问题带来的成功提交。</p><p>解决方法: 在变量前面加上版本号，每次变量更新的时候变量的版本号都+1，即A-&gt;B-&gt;A就变成了1A-&gt;2B-&gt;3A。(此A已经不是当初的A了)</p><h4 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h4><p>如果CAS操作失败，就需要循环进行CAS操作(循环同时将期望值更新为最新的)，如果长时间都不成功的话，那么会造成CPU极大的开销。</p><p>这种循环也称为自旋</p><p>解决方法: 限制自旋次数，防止进入死循环。</p><p>参考资料：<br><a href="https://juejin.im/post/5c87afa06fb9a049f1550b04">https://juejin.im/post/5a803e61f265da4e914b5b63</a><br><a href="https://juejin.im/post/5a803e61f265da4e914b5b63">https://juejin.im/post/5a803e61f265da4e914b5b63</a></p>]]></content>
    
    
    <summary type="html">Java中有各种各样的锁，在此做一个记录。</summary>
    
    
    
    <category term="Java" scheme="http://zhaojun.me/categories/Java/"/>
    
    
    <category term="java" scheme="http://zhaojun.me/tags/java/"/>
    
    <category term="锁" scheme="http://zhaojun.me/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Java Volatile关键字</title>
    <link href="http://zhaojun.me/2019/09/02/Java-Volatile/"/>
    <id>http://zhaojun.me/2019/09/02/Java-Volatile/</id>
    <published>2019-09-02T06:51:35.000Z</published>
    <updated>2019-09-08T07:21:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>一旦一个共享变量（类的成员变量、 类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p><ul><li>1.保证了不同线程对这个变量进行读取时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 (volatile 解决了线程间共享变量的可见性问题)。</li><li>2.禁止进行指令重排序， 阻止编译器对代码的优化</li></ul><p>volatile通过保证对变量的读或写都是直接从内存中读取或直接写入内存中，保证了可见性；但是volatile并不足以保证线程安全，因为无法保证原子性，如count++操作：</p><ul><li>1.将值从内存读入寄存器中</li><li>2.进行加1操作，内存保存到寄存器中</li><li>3.结果从寄存器flush到内存中<br>借用一张图来看：</li></ul><img src="/2019/09/02/Java-Volatile/a.png" class="" title="图1-1"> <p>不是volatile的变量的指令执行顺序是1-&gt;2-&gt;3；而声明为volatile的变量，顺序是1-&gt;23。从这里看，volatile保证了一个线程修改了volatile修饰的变量，变化会马上体现在内存中。线程间看到的值是一样的。</p><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：保证了不同线程对这个变量进行读取时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。(volatile 解决了线程间共享变量的可见性问题)。禁止进行指令重排序，阻止编译器对代码的优化。</p><p>上面说了无法保证原子性是指：多核cpu，线程A执行了指令1，线程B也执行了指令1。A进行了加1操作，结果写入寄存器同时flush到内存；随后B也执行了同样的操作。count本来应该的结果是加2，但是却只加了1。原因就是我们通常所指的读和写不是原子操作。我们最希望看到的是123同时执行，手段就是sychronized或者java.util.concurrent包中的原子数据类型。</p><p>简单拿AtomicInteger来看，其中的一个int类型的value字段声明为volatile，保证了123同时执行。</p><h3 id="2、内存可见性"><a href="#2、内存可见性" class="headerlink" title="2、内存可见性"></a>2、内存可见性</h3><p>volatile修饰的变量执行的操作(可以参考前文<a href="https://juejin.im/post/5acdb75951882555635ead2c">Java内存模型与线程</a>)：</p><ul><li>1.使用 volatile 关键字会强制将修改的值立即写入主存</li><li>2.使用 volatile 关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效；</li><li>3.由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</li></ul><h3 id="3、禁止重排序"><a href="#3、禁止重排序" class="headerlink" title="3、禁止重排序"></a>3、禁止重排序</h3><p>volatile 关键字禁止指令重排序有两层意思：</p><ul><li>1.当程序执行到 volatile 变量的读操作或者写操作时， 在其前面的操作的更改肯定全部已经进行， 且结果已经对后面的操作可见；</li><li>2.在其后面的操作肯定还没有进行在进行指令优化时， 不能把 volatile 变量前面的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行。</li></ul><p>为了实现volatile的内存语义，加入volatile关键字时，编译器在生成字节码时，会在指令序列中插入内存屏障，会多出一个lock前缀指令。内存屏障是一组处理器指令，解决禁止指令重排序和内存可见性的问题。编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。处理器在进行重排序时是会考虑指令之间的数据依赖性。</p><p>内存屏障，有2个作用：</p><ul><li>1.先于这个内存屏障的指令必须先执行， 后于这个内存屏障的指令必须后执行。</li><li>2.使得内存可见性。所以如果你的字段是 volatile，在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主内存加载数据。在写指令之后插入写屏障，能让写入缓存的最新数据写回到主内存。</li></ul><p>Lock前缀指令在多核处理器下会引发了两件事情：</p><ul><li>1.将当前处理器中这个变量所在缓存行的数据会写回到系统内存。这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</li><li>2.它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。</li></ul><p>参考资料：<br><a href="https://juejin.im/post/5acdb75951882555635ead2c">Volatile作用及原理</a></p>]]></content>
    
    
    <summary type="html">Java中Volatile关键字</summary>
    
    
    
    <category term="Java" scheme="http://zhaojun.me/categories/Java/"/>
    
    
    <category term="锁" scheme="http://zhaojun.me/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>jdk1.8HashMap核心源码解读</title>
    <link href="http://zhaojun.me/2019/09/01/Java-hashMap1.8/"/>
    <id>http://zhaojun.me/2019/09/01/Java-hashMap1.8/</id>
    <published>2019-09-01T04:52:08.000Z</published>
    <updated>2019-09-08T07:14:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、TreeNode"><a href="#1、TreeNode" class="headerlink" title="1、TreeNode"></a>1、TreeNode</h3><p>1.8的hashMap引入了TreeNode类，实现了数组＋链表+红黑树的数据结构,这样查找链表上的元素时，可以不用遍历整个链表，通过红黑树大大优化了查询效率。通过了解put()方法和resize()扩容方法就能大致了解1.8的核心之处</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Node&lt;K,V&gt;[] tab即为1.7中的Entry&lt;K,V&gt;[] table数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//HashMap初始化时不一定会初始化table数组，所以此处进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//如果数组该位置还没有元素，直接放到数组中即可，存放的位置是 (n-1)&amp;hash，n是数组长度</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//如果已经是红黑树，那么通过红黑树直接插入该节点。 TreeNode代表红黑色结构，是Node的子类</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果是链表结构</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//如果原来链表长度已经大于8，那么就要变为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st (从数组上的那个开始算起大于8)</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果找到了，那么覆盖原来的值</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存在则覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//hashMap中的元素个数已经超过阈值，则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容  1.7是不断地在表头扩展元素，多线程有形成死锁的风险</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果原先已经有元素了</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果已经达到最大容量，则无法扩容了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则讲阈值扩大为原来的两倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化的时候threshold为总的容量cap，类似16</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">//cap为数组的长度，thr为数组长度乘以负载因子  12 = 16 * 0.75  </span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;<span class="comment">//赋值给新的阈值</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历原来的桶位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">//桶位不为null时</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//桶位上只有一个元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//不会重新hash，直接拿原来的hash和新的容量做与操作</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//如果是红黑色，则执行红黑色扩容</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">//如果原来是链表</span></span><br><span class="line">                    <span class="comment">//原来的链表根据高位不同会分成两条链表</span></span><br><span class="line">                    <span class="comment">//具体分析见下文</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//扩容之前元素的位置是hash&amp;(n-1)，n为总的容量， 扩容之后总容量变为2n，则元素位置为hash&amp;(2n-1)。假设原来</span></span><br><span class="line">                        <span class="comment">//容量是16，hash&amp;(n-1)则是hash的末四位，扩容之后为32，hash(2n-1)是hash的末五位。那么原来的元素hash值小于16，那么位置不变，</span></span><br><span class="line">                        <span class="comment">//大于或等于16，就是高位上多了一个1，即原位置加上16。</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;<span class="comment">//如果高位为0，代表位置不变</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//第二条链表</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;<span class="comment">//此时代表高位为1，位置要发生变化</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//第一条低位链表不为null</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">//直接整个链表赋值，数组索引位置不变。故把链表头放在新的数组位置上，hash值相同的元素组成的整个链表即实现了移动</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//高位链表buweinull时</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">//直接整个链表赋值在原来的位置加上原来的容量大小处。</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">jdk1.8核心源码</summary>
    
    
    
    <category term="Java" scheme="http://zhaojun.me/categories/Java/"/>
    
    
    <category term="集合" scheme="http://zhaojun.me/tags/%E9%9B%86%E5%90%88/"/>
    
    <category term="源码" scheme="http://zhaojun.me/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="Map" scheme="http://zhaojun.me/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建</title>
    <link href="http://zhaojun.me/2017/11/05/hexo/"/>
    <id>http://zhaojun.me/2017/11/05/hexo/</id>
    <published>2017-11-05T08:05:35.000Z</published>
    <updated>2017-11-05T08:31:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天hexo出问题了，然后重新安装时，又费好多时间，记录一下<br><a href="https://hexo.io/zh-cn/docs/">hexo文档</a></p><h3 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h3><p>安装的方法以上文档很全。先要安装nodejs和git。然后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo init &lt;folder&gt; &#x2F;&#x2F;文件名</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>然后hexo s就能运行了。</p><h3 id="3、自定义主题"><a href="#3、自定义主题" class="headerlink" title="3、自定义主题"></a>3、自定义主题</h3><p>github上有很多开源主题，我用的是<a href="https://github.com/tufu9441/maupassant-hexo">maupassant</a>。这个主题安装时要执行<code>npm install hexo-renderer-sass --save</code>,但是一直都因为科学上网的问题无法下载，可以使用镜像下载，执行以下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install cnpm -g --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org </span><br></pre></td></tr></table></figure><p>然后就可以使用cnpm命令了。cnpm和npm用法完全一致，只是在执行命令时使用cnpm替代npm。</p><h3 id="4、博文中插入图片"><a href="#4、博文中插入图片" class="headerlink" title="4、博文中插入图片"></a>4、博文中插入图片</h3><p>博文中插入图片只需要将_config.yml中的post_asset_folder属性设置为true，这样每当你使用hexo new 命令时，都会生成一个相同名字的文件夹，然后在博文中使用以下命令就可以引入图片了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img a.png &quot;图1-1&quot;%&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，网上很多都在说使用<code>npm install hexo-asset-image --save</code>命令，来用另外一种方式插入图片。这个我没试过，但是当使用前面那种方式时，不能安装这个包，否则生成最终的静态网页中的图片路径都会不对。</p><h3 id="5、上传到git"><a href="#5、上传到git" class="headerlink" title="5、上传到git"></a>5、上传到git</h3><p>先必须安装包<code>npm install hexo-deployer-git –save</code>,然后在_config.yml配置如下即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;git.coding.net&#x2F;XXXXXX&#x2F;xxx.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>其实还有很多其他可以自定义的东西，比如让百度谷歌搜索到自己的文章，支持评论等等。暂时感觉没啥用就不写了。</p>]]></content>
    
    
    <summary type="html">hexo搭建博客。</summary>
    
    
    
    <category term="hexo" scheme="http://zhaojun.me/categories/hexo/"/>
    
    
    <category term="hexo" scheme="http://zhaojun.me/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之动态代理模式</title>
    <link href="http://zhaojun.me/2017/10/31/design-pattern-proxy/"/>
    <id>http://zhaojun.me/2017/10/31/design-pattern-proxy/</id>
    <published>2017-10-31T07:51:27.000Z</published>
    <updated>2017-10-31T15:23:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>动态代理模式是设计模式中代理模式中的一种，它为其他对象提供一种代理以控制对这个对象的访问。优势是在某些情况下，一个实例不想或者不能直接引用另一种对象，而代理对象可以在客户端和目标之间起到中介的作用。</p><h3 id="1、无代理"><a href="#1、无代理" class="headerlink" title="1、无代理"></a>1、无代理</h3><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">接口如下：</span><br><span class="line">public interface Human &#123;</span><br><span class="line">    void eat(String food);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实现类：</span><br><span class="line">public class HumanImpl implements Human &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat(String food) &#123;</span><br><span class="line">        System.out.println(&quot;eat &quot; + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们可以稍微做些扩展思考。如果未来，我们需要在这个eat()方法前后加一些逻辑呢？比如先做饭，吃完以后打扫。</p><p>当然我们可以把做饭和打扫的逻辑一并写在eat()方法内部，只是这样做会失去很多灵活性，比如今天不做饭扥等。</p><h3 id="2、静态代理"><a href="#2、静态代理" class="headerlink" title="2、静态代理"></a>2、静态代理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class HumanProxy implements Human &#123;</span><br><span class="line">    private Human human;</span><br><span class="line"></span><br><span class="line">    public HumanProxy() &#123;</span><br><span class="line">        human &#x3D; new HumanProxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat(String food) &#123;</span><br><span class="line">        before();</span><br><span class="line">        human.eat(food);</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void before() &#123;</span><br><span class="line">        System.out.println(&quot;cook&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void after() &#123;</span><br><span class="line">        System.ut.println(&quot;swap&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new HumanProxy().eat(&quot;rice&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现HumanProxy实现了Human接口(和HumanImpl实现相同的接口)，虽然我们也是在调用eat方法，但是代理类加上了新的动作。但是要是有很多种动作，各种动作组合起来就需要HumanProxy持有很多代理类(或者新的Human实现类)，非常繁琐。</p><h3 id="3、动态代理"><a href="#3、动态代理" class="headerlink" title="3、动态代理"></a>3、动态代理</h3><p>动态代理能将”吃饭”和”打扫”、”做饭”的逻辑解耦开，分别实现，这样就会很灵活，复用很多代码。例如下面的例子中，我们可以一直复用DynamicProxy动态代理类，通过传入不同的对象或者属性，来执行相应对象的需求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicProxy implements InvocationHandler&#123;&#x2F;&#x2F;继承该接口，该接口只声明了一个方法</span><br><span class="line"></span><br><span class="line">private Object target;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里可以新增很多其他的属性</span><br><span class="line"></span><br><span class="line">public DynamicProxy(Object target) &#123;</span><br><span class="line">this.target &#x3D; target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;增加其他逻辑</span><br><span class="line">System.out.println(&quot;cook&quot;);这里可以很灵活，例如该类持有一个其他的对象，然后操作这个对象</span><br><span class="line">Object result &#x3D; method.invoke(target, args);</span><br><span class="line">System.out.println(&quot;swap&quot;);</span><br><span class="line">&#x2F;&#x2F;增加其他逻辑</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class TestProxy &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Human realHuman &#x3D; new HumanImpl();</span><br><span class="line">InvocationHandler handler &#x3D; new DynamicProxy(realHuman);</span><br><span class="line"></span><br><span class="line">Human human &#x3D; (Human) Proxy.newProxyInstance(realHuman.getClass().getClassLoader(), realHuman.getClass().getInterfaces(), handler);</span><br><span class="line"></span><br><span class="line">System.out.println(human.getClass().getName());&#x2F;&#x2F;输出com.sun.proxy.$Proxy0</span><br><span class="line">human.eat(&quot;rice&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出：</span><br><span class="line">com.sun.proxy.$Proxy0 &#x2F;&#x2F;后面解释这个的原因</span><br><span class="line">before</span><br><span class="line">eat rice</span><br><span class="line">after</span><br></pre></td></tr></table></figure><h3 id="4、源码"><a href="#4、源码" class="headerlink" title="4、源码"></a>4、源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader,</span><br><span class="line">                                        Class&lt;?&gt;[] interfaces,</span><br><span class="line">                                        InvocationHandler h)</span><br><span class="line">    throws IllegalArgumentException</span><br><span class="line">&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    final Class&lt;?&gt;[] intfs &#x3D; interfaces.clone();</span><br><span class="line">    final SecurityManager sm &#x3D; System.getSecurityManager();</span><br><span class="line">    if (sm !&#x3D; null) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; cl &#x3D; getProxyClass0(loader, intfs);&#x2F;&#x2F;核心，生成代理类，生成代理类，</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        if (sm !&#x3D; null) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final Constructor&lt;?&gt; cons &#x3D; cl.getConstructor(constructorParams);</span><br><span class="line">        final InvocationHandler ih &#x3D; h;</span><br><span class="line">        if (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                public Void run() &#123;</span><br><span class="line">                    cons.setAccessible(true);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        return cons.newInstance(new Object[]&#123;h&#125;);</span><br><span class="line">   .......省略异常处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>getProxyClass0</code>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                           Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">        if (interfaces.length &gt; 65535) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return proxyClassCache.get(loader, interfaces);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进入<code>get</code>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public V get(K key, P parameter) &#123;</span><br><span class="line">        ......省略一堆</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (supplier !&#x3D; null) &#123;</span><br><span class="line">                V value &#x3D; supplier.get();</span><br><span class="line">                if (value !&#x3D; null) &#123;</span><br><span class="line">                    return value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         ......省略一堆  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进入<code>WeakCache</code>类的<code>get</code>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V get() &#123; &#x2F;&#x2F; serialize access</span><br><span class="line">           ...省略一堆</span><br><span class="line">            try &#123;</span><br><span class="line">                value &#x3D; Objects.requireNonNull(valueFactory.apply(key, parameter));</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (value &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; remove us on failure</span><br><span class="line">                    valuesMap.remove(subKey, this);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           ...省略一堆</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>沿着<code>valueFactory.apply(key, parameter)</code>进入<code>Proxy</code>类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">       ......省略一堆</span><br><span class="line">        byte[] proxyClassFile &#x3D; ProxyGenerator.generateProxyClass(</span><br><span class="line">            proxyName, interfaces, accessFlags);&#x2F;&#x2F;生成字节码文件</span><br><span class="line">        try &#123;</span><br><span class="line">            return defineClass0(loader, proxyName,</span><br><span class="line">                                proxyClassFile, 0, proxyClassFile.length);</span><br><span class="line">        &#125; catch (ClassFormatError e) &#123;</span><br><span class="line">            </span><br><span class="line">            throw new IllegalArgumentException(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>沿着<code>generateProxyClass</code>进入<code>ProxyGenerator</code>类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] generateProxyClass(final String var0, Class&lt;?&gt;[] var1, int var2) &#123;</span><br><span class="line">        ProxyGenerator var3 &#x3D; new ProxyGenerator(var0, var1, var2);</span><br><span class="line">        final byte[] var4 &#x3D; var3.generateClassFile();</span><br><span class="line">        if(saveGeneratedFiles) &#123;</span><br><span class="line">            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                public Void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int var1 &#x3D; var0.lastIndexOf(46);</span><br><span class="line">                        Path var2;</span><br><span class="line">                        if(var1 &gt; 0) &#123;</span><br><span class="line">                            Path var3 &#x3D; Paths.get(var0.substring(0, var1).replace(&#39;.&#39;, File.separatorChar), new String[0]);</span><br><span class="line">                            Files.createDirectories(var3, new FileAttribute[0]);&#x2F;&#x2F;新建一个目录文件</span><br><span class="line">                            var2 &#x3D; var3.resolve(var0.substring(var1 + 1, var0.length()) + &quot;.class&quot;);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            var2 &#x3D; Paths.get(var0 + &quot;.class&quot;, new String[0]);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        Files.write(var2, var4, new OpenOption[0]);</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125; catch (IOException var4x) &#123;</span><br><span class="line">                        throw new InternalError(&quot;I&#x2F;O exception saving generated file: &quot; + var4x);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] generateProxyClass(final String var0, Class&lt;?&gt;[] var1, int var2) &#123;</span><br><span class="line">        ProxyGenerator var3 &#x3D; new ProxyGenerator(var0, var1, var2);</span><br><span class="line">        final byte[] var4 &#x3D; var3.generateClassFile();</span><br><span class="line">        if(saveGeneratedFiles) &#123;</span><br><span class="line">            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                public Void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int var1 &#x3D; var0.lastIndexOf(46);</span><br><span class="line">                        Path var2;</span><br><span class="line">                        if(var1 &gt; 0) &#123;</span><br><span class="line">                            Path var3 &#x3D; Paths.get(var0.substring(0, var1).replace(&#39;.&#39;, File.separatorChar), new String[0]);</span><br><span class="line">                            Files.createDirectories(var3, new FileAttribute[0]);</span><br><span class="line">                            var2 &#x3D; var3.resolve(var0.substring(var1 + 1, var0.length()) + &quot;.class&quot;);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            var2 &#x3D; Paths.get(var0 + &quot;.class&quot;, new String[0]);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        Files.write(var2, var4, new OpenOption[0]);</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125; catch (IOException var4x) &#123;</span><br><span class="line">                        throw new InternalError(&quot;I&#x2F;O exception saving generated file: &quot; + var4x);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return var4;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>根据上面最后一部分源码，实际上就是编译器构造了一个子类com.sun.proxy.$Proxy0，继承并实现了Human接口，并且持有了handler引用，当调用eat方法时，就会进入$Proxy0类调用其实现的eat方法，然后在方法中调用handler的invoke方法。进而实现代理过程。</p>]]></content>
    
    
    <summary type="html">动态代理在Java框架中应用得极为广泛。如Spring中的AOP，Struts2中的拦截器等。</summary>
    
    
    
    <category term="设计模式" scheme="http://zhaojun.me/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="proxy" scheme="http://zhaojun.me/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>netty学习</title>
    <link href="http://zhaojun.me/2017/10/31/netty/"/>
    <id>http://zhaojun.me/2017/10/31/netty/</id>
    <published>2017-10-31T07:12:59.000Z</published>
    <updated>2017-10-31T15:23:25.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="NIO："><a href="#NIO：" class="headerlink" title="NIO："></a>NIO：</h4><p><a href="http://ifeve.com/overview/">http://ifeve.com/overview/</a><br><a href="http://www.cnblogs.com/dolphin0520/category/602385.html">http://www.cnblogs.com/dolphin0520/category/602385.html</a></p><h4 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h4><p><a href="http://blog.csdn.net/column/details/enjoynetty.html">http://blog.csdn.net/column/details/enjoynetty.html</a></p><p><a href="http://www.cnblogs.com/applerosa/p/7141684.html">http://www.cnblogs.com/applerosa/p/7141684.html</a></p><p><a href="http://www.cnblogs.com/cishengchongyan/category/917152.html">http://www.cnblogs.com/cishengchongyan/category/917152.html</a></p><p><a href="http://budairenqin.iteye.com/category/257474">http://budairenqin.iteye.com/category/257474</a></p>]]></content>
    
    
    <summary type="html">netty学习</summary>
    
    
    
    <category term="netty" scheme="http://zhaojun.me/categories/netty/"/>
    
    
    <category term="netty" scheme="http://zhaojun.me/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>常用命令</title>
    <link href="http://zhaojun.me/2017/10/23/commands/"/>
    <id>http://zhaojun.me/2017/10/23/commands/</id>
    <published>2017-10-23T03:37:59.000Z</published>
    <updated>2019-09-08T06:16:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>./nginx -t 检查配置</p><p>./nginx -s reload  重新加载配置文件</p><p>service nginx restart 重启nginx服务</p><p>select * from test.orderMemDB-lineItemMap where pk = 8593;<br>delete from akulaku.memCacheKeys where pk = ‘insuranceMemDB-insuranceMap’<br>select * from akulaku.memCacheKeys</p><p>OPERATE MAP_PUT(ids, 1, 1) ON akulaku.activityModuleMemDB-serviceActivityModuleMap where PK = 2</p><p>OPERATE LIST_APPEND(listbin, 1), LIST_APPEND(listbin2, 10) ON test.demo where PK = ‘key1’</p><p>sudo iptables -I INPUT -p udp –dport 5060 -j DROP<br>sudo iptables -I INPUT -s 192.168.1.0/24 -p tcp –dport 80 -j ACCEPT<br>sudo iptables -I INPUT -s 117.102.124.150 -j ACCEPT</p><p>拷贝文件 服务器到本地(./代表当前目录)<br>scp -i ~/akulaku-test <a href="mailto:&#117;&#98;&#117;&#x6e;&#116;&#x75;&#64;&#53;&#50;&#46;&#x38;&#x2e;&#x31;&#x30;&#56;&#46;&#50;&#x34;&#x37;">&#117;&#98;&#117;&#x6e;&#116;&#x75;&#64;&#53;&#50;&#46;&#x38;&#x2e;&#x31;&#x30;&#56;&#46;&#50;&#x34;&#x37;</a>:/home/ubuntu/data/akulaku_sources/lemon-nodejs/result.json ./<br>本地到服务器<br>scp -i  ~/akulaku-test lineiteminfo.js <a href="mailto:&#x75;&#x62;&#117;&#x6e;&#x74;&#x75;&#x40;&#53;&#50;&#46;&#56;&#46;&#x31;&#x30;&#x38;&#x2e;&#50;&#x34;&#x37;">&#x75;&#x62;&#117;&#x6e;&#x74;&#x75;&#x40;&#53;&#50;&#46;&#56;&#46;&#x31;&#x30;&#x38;&#x2e;&#50;&#x34;&#x37;</a>:/home/ubuntu/data/akulaku_sources/lemon-nodejs/  </p><p>sudo freeswitch -nc<br>fs_cli</p><p>查询端口占用，之后根据pid查询任务<br>netstat -anp|grep 9999<br>ps -aux|grep 31727</p><p> kill -9 $pid</p><p>show full processlist; </p><p>sofia profile internal siptrace on<br>sofia profile internal siptrace off</p><p>sofia status profile internal<br>sofia status profile internal reg</p><p>sudo iptables -I INPUT -p udp –dport 5060 -j DROP<br>sudo iptables -I INPUT -s 192.168.1.0/24 -p tcp –dport 80 -j ACCEPT<br>sudo iptables -I INPUT -s 117.102.124.150 -j ACCEPT</p><p>ssh -i  ~/akulaku-test <a href="mailto:&#x75;&#98;&#117;&#110;&#116;&#117;&#64;&#x35;&#50;&#46;&#x38;&#46;&#x31;&#x30;&#56;&#x2e;&#x32;&#52;&#55;">&#x75;&#98;&#117;&#110;&#116;&#117;&#64;&#x35;&#50;&#46;&#x38;&#46;&#x31;&#x30;&#56;&#x2e;&#x32;&#52;&#55;</a></p><p>asinfo -v “truncate:namespace=akulaku;set=akulaku.activityModuleMemDB-serviceActivityModuleMap;”</p><p>rdb -e “select * from t_call where create_time &gt; 1509494400000 and create_time &lt;1512000000000” &gt;call1509494400000.sql</p><p>sudo add-apt-repository ppa:cwchien/gradle  </p><p>sudo apt-get update  更新源</p><p>apt-cache search gradle  查看可安装的gradle版本</p><p>apt-cache search commoncpp2</p><p>javac -cp asterisk-java.jar HelloAgiScript.java<br>java -jar asterisk-java.jar<br>java -cp asterisk-java.jar:. org.asteriskjava.fastagi.DefaultAgiServer</p><p>curl -l “<a href="http://127.0.0.1:8080/call/api/call/dialstatus?dialResult=&quot;busy&quot;&quot;">http://127.0.0.1:8080/call/api/call/dialstatus?dialResult=&quot;busy&quot;&quot;</a></p><p>mysql –local-infile -u root -p123456</p><p>导出多个表<br>mysqldump -uroot -p123456 –databases calldb –tables t_call_20171120 t_call_20171121 t_call_20171122 t_call_20171123 t_call_20171124  &gt; t_call_20.sql<br>单个表<br>mysqldump -uroot -p123456 –databases installmentdb –tables t_activity_module  &gt; t_activity_module.sql</p>]]></content>
    
    
    <summary type="html">常用命令总结</summary>
    
    
    
    <category term="other" scheme="http://zhaojun.me/categories/other/"/>
    
    
    <category term="other" scheme="http://zhaojun.me/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>Kafka</title>
    <link href="http://zhaojun.me/2017/10/22/Kafka/"/>
    <id>http://zhaojun.me/2017/10/22/Kafka/</id>
    <published>2017-10-22T06:37:49.000Z</published>
    <updated>2017-10-25T12:46:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、消息队列-Message-Queue"><a href="#1、消息队列-Message-Queue" class="headerlink" title="1、消息队列(Message Queue)"></a>1、消息队列(Message Queue)</h3><p>MQ模型：  </p><img src="/2017/10/22/Kafka/a.jpeg" class="" title="图1">  <p>通过消息队列，我们可以完成两个系统之间的交互，实现系统间的调用与协调。<br>1、解耦合<br>2、提高系统响应时间</p><h3 id="2、消息队列分类"><a href="#2、消息队列分类" class="headerlink" title="2、消息队列分类"></a>2、消息队列分类</h3><h4 id="2-1、点对点"><a href="#2-1、点对点" class="headerlink" title="2.1、点对点"></a>2.1、点对点</h4><p>消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并且消费消息。消息被消费以后，queue中不再有存储，所以消息消费者不可能消费到已经被消费的消息。queue支持存在多个消费者，但是对一个消息而言，只有一个消息消费者可以被消费(很大的一个缺点)。</p><h4 id="2-2、发布／订阅-常用"><a href="#2-2、发布／订阅-常用" class="headerlink" title="2.2、发布／订阅(常用)"></a>2.2、发布／订阅(常用)</h4><p>消息生产者(发布)将消息发布到topic中，同时有多个消息消费者(订阅)消费该消息。和点对点不同的是，发布到topic中的消息会被所有订阅者消费</p><h3 id="3、Kafka"><a href="#3、Kafka" class="headerlink" title="3、Kafka"></a>3、Kafka</h3><p>Kafka是分布式发布-订阅消息系统，特点如下：</p><ul><li>同时为发布和订阅提高吞吐量</li><li>可进行持久化操作。讲消息持久化磁盘，因此可用于批量消费，以及实时应用程序。通过将数据持久化磁盘防止丢失</li><li>分布式系统。易于扩展，所有的roducer，broker(就是上图中那个消息队列管道)，consumer都会有多个，均为分布式的。无需停机器即可扩展</li><li>消息被处理的状态是在consumer端维护。内置了zookeeper，能够一直监听，就可以维护各种状态</li><li>支持online和offline场景</li></ul><h3 id="4、Kafka组成"><a href="#4、Kafka组成" class="headerlink" title="4、Kafka组成"></a>4、Kafka组成</h3><h4 id="4-1、Kafka逻辑结构"><a href="#4-1、Kafka逻辑结构" class="headerlink" title="4.1、Kafka逻辑结构"></a>4.1、Kafka逻辑结构</h4><p>Kafka如图所示：</p><img src="/2017/10/22/Kafka/b.jpeg" class="" title="图2">  <ul><li>producer：消息生产者</li><li>consumer：消息消费者</li><li>consumer group：消费者组，可以并行消费topic中的partition消息</li><li>broker： 缓存代理，kafka集群中的一台或者多台服务器统称为broker</li><li>topic：kafka处理的消息源的不同分类</li><li>partition：topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id(offset)</li><li>message：消息，是通信的基本单位，每个producer可以向一个topic发布一些消息</li><li>producers：消息和数据生产者，向Kafka的一个topic发布消息的过程称为producers</li><li>consumers：消息和数据消费者，订阅topic并处理其发布的消息的过程叫做consumers</li></ul><h4 id="4-2、Kafka的produces"><a href="#4-2、Kafka的produces" class="headerlink" title="4.2、Kafka的produces"></a>4.2、Kafka的produces</h4><p>produces将消息发布到指定的topic中，同producers也能决定讲此消息归属到哪个partition；比如基于“round-robin”方式，同时还支持批量发送，能够有效的提高效率。kafka的异步发送模式允许进行批量发送，先将消息缓存到内存中，然后一次批量发送出去。</p><h4 id="4-3、Kafka的broker"><a href="#4-3、Kafka的broker" class="headerlink" title="4.3、Kafka的broker"></a>4.3、Kafka的broker</h4><p>broker就是缓存代理，kafka集群中一台或者多台服务器统称为broker。message在broker中通过log追加的方式进行持久化存储。并进行分区(partition)。为了减少磁盘写入的次数，broker会将消息暂时buffer起来，当消息的个数(或尺寸)达到一定的阀值时，再flush到磁盘，这样就减少了磁盘io的调用次数。broker是无状态机制的：</p><ul><li> broker没有副本保存，一旦broker宕机，该broker消息将都不可用，但是其他的broker可以通过消息的日志文件恢复该消息，所以消息是不会丢失的</li><li> broker不保存订阅者的状态，由订阅者自己保存(配合zookeeper)</li><li> 无状态导致消息的删除成为难题(可能删除的消息正在被订阅)，kafka采用基于时间的sla，消息保存一定时间后(通常时7天)会被删除</li><li> 消息订阅者回到任意位置进行重新消费，当订阅者故障时，可以选择最小的offset(id)进行重新消费读取消息</li></ul><h4 id="4-4、Kafka的message组成"><a href="#4-4、Kafka的message组成" class="headerlink" title="4.4、Kafka的message组成"></a>4.4、Kafka的message组成</h4><p>message消息是通信的基本单位，每个producer可以向一个topic发布一些主题消息。Kafka的message是以topic为基本单位组织的，不同的topic之间是相互独立的。每个topic又可以分成几个不同的partition(每个topic有几个partition是在创建topic时指定的)，每个partition存储一部分message。每个message包含了三个属性：</p><ul><li>offset：long类型</li><li>messageSize：消息内容的带下，int32类型，可用于校验</li><li>data：message的具体内容</li></ul><h4 id="4-5、Kafka的partition分区的目的"><a href="#4-5、Kafka的partition分区的目的" class="headerlink" title="4.5、Kafka的partition分区的目的"></a>4.5、Kafka的partition分区的目的</h4><p>主要有三个目的：</p><ul><li>Kafka基于文件存储，通过分区可以将日志分散到多个server上，来避免文件尺寸，达到单个磁盘的上限，每个partition都会被当前server(kafka实例)保存</li><li>还可以通过topic切分为任意多个partitions，来消息保存／消费的效率</li><li>越多的partitions意味着可以容纳更多的consumer，有效提升并发消费能力</li></ul><h4 id="4-5、Kafka的consumer"><a href="#4-5、Kafka的consumer" class="headerlink" title="4.5、Kafka的consumer"></a>4.5、Kafka的consumer</h4><p>消息和数据订阅者，订阅topics并处理其发布消息的过程叫做consumers。在kafka中，我们可以认为一个group是一个订阅者，一个topic的每个partitions，只会被一个订阅者中的一个consumer消费，不过一个consumer可以消费多个partitions中的消息(消费者数据小于partitions数量时)。需要注意的是，kafka的设计原理决定，对于一个topic，同一个group中不能有多于partitions个数的consumer同时消费，否则将意味着某些consumer将无法得到消息，但是可以使用不同的group来消费同一条消息。</p><h3 id="5、Kafka的持久化"><a href="#5、Kafka的持久化" class="headerlink" title="5、Kafka的持久化"></a>5、Kafka的持久化</h3><p>一个topic可以认为是一类消息，每个topic将被分为多个partition，每个partition都是一个有序的队列，partition中的每条消息都有一个id。另外，partition在存储层面是append log文件。任何发布到此partition的消息都会被直接追加到log文件的尾部，每条消息在文件中的位置称为偏移量(offset)，partition是以文件的形式存储在文件系统中。logs文件根据broker中的配置要求，保留一定时间后删除来释放磁盘空间。</p><img src="/2017/10/22/Kafka/c.jpg" class="" title="图3">  <p>kafka会为数据文件建立稀疏索引，即每隔一定字节数据建立一条索引，下列是一个partition的索引示意图：</p><img src="/2017/10/22/Kafka/d.jpeg" class="" title="图4">  ]]></content>
    
    
    <summary type="html">现在消息队列有很多种，kafka是其中之一</summary>
    
    
    
    <category term="Kafka" scheme="http://zhaojun.me/categories/Kafka/"/>
    
    
    <category term="Kafka" scheme="http://zhaojun.me/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper3</title>
    <link href="http://zhaojun.me/2017/10/22/zookeeper3/"/>
    <id>http://zhaojun.me/2017/10/22/zookeeper3/</id>
    <published>2017-10-22T05:22:49.000Z</published>
    <updated>2017-11-06T14:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、分布式与数据复制"><a href="#1、分布式与数据复制" class="headerlink" title="1、分布式与数据复制"></a>1、分布式与数据复制</h3><p>zookeeper作为一个集群提供一致的数据服务，自然，它要在所有机器间做数据复制。数据复制的好处：</p><ul><li>容错：一个节点出错，不致于让整个系统停止工作，别的节点可以接管它的工作；</li><li>提高系统的扩展能力：把负载分布到多个节点上，或者增加节点来提高系统的负载能力；</li><li>提高性能：让客户端本地访问就近的节点，提高用户访问速度。<br> <br>从客户端读写访问的透明度来看，数据复制集群系统分下面两种：</li><li>写主(WriteMaster)：对数据的修改提交给指定的节点。读无此限制，可以读取任何一个节点。这种情况下客户端需要对读与写进行区别，俗称读写分离；</li><li>写任意(Write Any)：对数据的修改可提交给任意的节点，跟读一样。这种情况下，客户端对集群节点的角色与变化透明。<br> <br>对zookeeper来说，它采用的方式是写任意。通过增加机器，它的读吞吐能力和响应能力扩展性非常好，而写，随着机器的增多吞吐能力肯定下降（这也是它建立observer的原因），而响应能力则取决于具体实现方式，是延迟复制保持最终一致性，还是立即复制快速响应。<br>我们关注的重点还是在如何保证数据在集群所有机器的一致性，这就涉及到paxos算法。 <h3 id="2、数据一致性与paxos算法-很有意思"><a href="#2、数据一致性与paxos算法-很有意思" class="headerlink" title="2、数据一致性与paxos算法(很有意思)"></a>2、数据一致性与paxos算法(很有意思)</h3>据说Paxos算法的难理解与算法的知名度一样令人敬仰，所以我们先看如何保持数据的一致性，这里有个原则就是：  </li></ul><p>在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。  </p><p>Paxos算法解决的什么问题呢，解决的就是保证每个节点执行相同的操作序列。好吧，这还不简单，master维护一个全局写队列，所有写操作都必须放入这个队列编号，那么无论我们写多少个节点，只要写操作是按编号来的，就能保证一致性。没错，就是这样，可是如果master挂了呢。<br>Paxos算法通过投票来对写操作进行全局编号，同一时刻，只有一个写操作被批准，同时并发的写操作要去争取选票，只有获得过半数选票的写操作才会被批准（所以永远只会有一个写操作得到批准），其他的写操作竞争失败只好再发起一轮投票，就这样，在日复一日年复一年的投票中，所有写操作都被严格编号排序。编号严格递增，当一个节点接受了一个编号为100的写操作，之后又接受到编号为99的写操作（因为网络延迟等很多不可预见原因），它马上能意识到自己数据不一致了，自动停止对外服务并重启同步过程。任何一个节点挂掉都不会影响整个集群的数据一致性（总2n+1台，除非挂掉大于n台）。</p><h3 id="3、ZAB协议"><a href="#3、ZAB协议" class="headerlink" title="3、ZAB协议"></a>3、ZAB协议</h3><p>ZooKeeper Atomic Broadcast 即ZooKeeper原子消息广播协议，简称ZAB。选举过程与数据写入过程都依赖该协议，Zab的核心是定义了那些会改变zk服务器数据状态的事务请求的处理方式。</p><p>Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。<br>为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。</p><p>所有事务请求必须由一个全局唯一的服务器来协调处理，这样的的服务器被称Leader服务器， 而余下的其它服务器则成为Follower服务器。Leader服务器负责将一个客户端事务请求转换成一个事务Proposal(提议)，并将Proposal分发给集群中所有的Follower服务器(Observer不参与)。之后Leader服务器需要等待所有Follower服务器的反馈，一旦超过半数的Follower服务器进行了正确的反馈后，那么Leader就会再次等待向所有的Follower服务器分发Commit消息，要求其将前一个Proposal进行提交。</p><h4 id="3-1、ZAB协议三阶段"><a href="#3-1、ZAB协议三阶段" class="headerlink" title="3.1、ZAB协议三阶段"></a>3.1、ZAB协议三阶段</h4><ul><li>发现：即选举Leader过程</li><li>同步：选举出新的leader后，follower或者observer从leader同步最新数据</li><li>广播：同步完成后，就可以接收客户端请求，并进行消息广播，实现数据在集群节点的副本存储<br>为了避免重复创建两个节点之间的tcp连接，zk按照myid数值方向建立连接，即小数的节点向大的节点发起连接</li></ul><h3 id="4、服务器状态"><a href="#4、服务器状态" class="headerlink" title="4、服务器状态"></a>4、服务器状态</h3><p>org.apache.zookeeper.server.quorum. ServerState类维护了四种状态：</p><ul><li>LOOKING：寻找leader状态，当服务器处于此状态时，表示当前没有leader，需要进入选举流程</li><li>FOLLOWING：跟随者状态，表明当前服务器是跟随者</li><li>OBSERVING：观察者状态，表明当前服务器是Observer</li><li>LEADING：领导者状态，表明当前服务器是leader</li></ul><h3 id="5、ZK选举"><a href="#5、ZK选举" class="headerlink" title="5、ZK选举"></a>5、ZK选举</h3><p>当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。只有拥有最新数据的节点才能有机会成Leader，通过事务id(zxid)的大小来表示数据的新 ，越大代表数据越新。集群启动时，会在data目录下配置myid文件，里面的数字代表当前zk服务器节点的编号，当zk服务器节点数据一样新时，myid中数据越大的就会被选举成Leader，新加入的节点不会影响原来的集群。</p><h4 id="5-1、basic-paxos算法选举"><a href="#5-1、basic-paxos算法选举" class="headerlink" title="5.1、basic paxos算法选举"></a>5.1、basic paxos算法选举</h4><p>basic paxos流程：</p><ul><li>选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server；</li><li>选举线程首先向所有Server发起一次询问(包括自己)；</li><li>选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；</li><li>收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server；</li><li>线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2 + 1的Server票数， 设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。</li></ul><p>通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1.<br>每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复</p><h4 id="5-2、fast-paxos算法流程："><a href="#5-2、fast-paxos算法流程：" class="headerlink" title="5.2、fast paxos算法流程："></a>5.2、fast paxos算法流程：</h4><p>假设有三台机器，此时server2为主，并且server2宕机<br>选举流程如下：</p><ul><li>所有节点变更为looking状态</li><li>每个server发出一个投自己的票的信息，先生成投票信息(myid, ZXID)，例如server1为(1,123)，server3为(3,122)，server1发给3，server3发给1</li><li>server3收到1后，发现123比122大2，修改自己的投票信息为(1,123)发给1；server1接收到3后，发现122比123小，不改变自己的投票</li><li>统计投票，server1和3都发现自己收到的投票中(包括自己的)，(1,123)是两票</li><li>修改状态，server1选出leader是1，而自己就是1，故更新为leading状态，server3选举出1，但是自己是3，更新为following状态</li><li>同步数据</li></ul><h3 id="6、同步流程"><a href="#6、同步流程" class="headerlink" title="6、同步流程"></a>6、同步流程</h3><p>选完leader以后，zk就进入状态同步过程。</p><ul><li>leader等待server连接；</li><li>Follower连接leader，将最大的zxid发送给leader；</li><li>Leader根据follower的zxid确定同步点；</li><li>完成同步后通知follower 已经成为uptodate状态；</li><li>Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。</li></ul><h3 id="7、工作流程"><a href="#7、工作流程" class="headerlink" title="7、工作流程"></a>7、工作流程</h3><h4 id="7-1-Leader工作流程"><a href="#7-1-Leader工作流程" class="headerlink" title="7.1 Leader工作流程"></a>7.1 Leader工作流程</h4><p>Leader主要有三个功能：</p><ul><li>恢复数据；</li><li>维持与Learner的心跳，接收Learner请求并判断Learner的请求消息类型；</li><li>Learner的消息类型主要有PING消息、REQUEST消息、ACK消息、REVALIDATE消息，根据不同的消息类型，进行不同的处理。<br>PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。</li></ul><h4 id="7-2-Follower工作流程"><a href="#7-2-Follower工作流程" class="headerlink" title="7.2 Follower工作流程"></a>7.2 Follower工作流程</h4><p>Follower主要有四个功能：</p><ul><li>向Leader发送请求(PING消息、REQUEST消息、ACK消息、REVALIDATE消息）</li><li>接收Leader消息并进行处理</li><li>接收Client的请求，如果为写请求，发送给Leader进行投票</li><li>返回Client结果</li></ul><p>Follower的消息循环处理如下几种来自Leader的消息：</p><ul><li>PING消息： 心跳消息</li><li>PROPOSAL消息：Leader发起的提案，要求Follower投票</li><li>COMMIT消息：服务器端最新一次提案的信息</li><li>UPTODATE消息：表明同步完成</li><li>REVALIDATE消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息</li><li>SYNC消息：返回SYNC结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新</li></ul>]]></content>
    
    
    <summary type="html">zookeeper核心原理</summary>
    
    
    
    <category term="zookeeper" scheme="http://zhaojun.me/categories/zookeeper/"/>
    
    
    <category term="zookeeper" scheme="http://zhaojun.me/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper2</title>
    <link href="http://zhaojun.me/2017/10/18/zookeeper2/"/>
    <id>http://zhaojun.me/2017/10/18/zookeeper2/</id>
    <published>2017-10-18T05:18:49.000Z</published>
    <updated>2017-10-25T12:44:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Watcher监听"><a href="#1、Watcher监听" class="headerlink" title="1、Watcher监听"></a>1、Watcher监听</h3><p>Zk中引入了watcher机制来实现了发布/订阅功能，能够让多个订阅者同时监听某一个主题对象，当某个主题对象自身状态变化时，会通知所有订阅者。</p><p>客户端向zk服务器注册watcher的同时，会将watcher对象储在客户端的watchManager中，当Zk服务器触发watcher事件后，会向客户端发送通知，客户端线程从watchManager中调起watcher执行。</p><p>watcher设置后，一旦触发一次，就会失效，再次监听需要再次注册</p><h3 id="2、demo"><a href="#2、demo" class="headerlink" title="2、demo"></a>2、demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class WatcherExample implements Watcher &#123;／／注册watcher需要实现该接口</span><br><span class="line">private String zkpath&#x3D;&quot;localhost:2181&quot;;</span><br><span class="line">@Override</span><br><span class="line">public void process(WatchedEvent event) &#123;</span><br><span class="line">System.out.println(&quot;watcher&#x3D;&quot;+this.getClass().getName());</span><br><span class="line">System.out.println(&quot;path&#x3D;&quot;+event.getPath());</span><br><span class="line">System.out.println(&quot;eventType&#x3D;&quot;+event.getType().name());</span><br><span class="line">        &#x2F;&#x2F;可以在这里再次注册，这样就能一直监听了</span><br><span class="line">&#125;</span><br><span class="line">public String getZkpath() &#123;</span><br><span class="line">return zkpath;</span><br><span class="line">&#125;</span><br><span class="line">public void setZkpath(String zkpath) &#123;</span><br><span class="line">this.zkpath &#x3D; zkpath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">WatcherExample  wx &#x3D; new WatcherExample();</span><br><span class="line">try &#123;</span><br><span class="line">ZooKeeper zk &#x3D; new ZooKeeper(wx.getZkpath(),10000, wx);&#x2F;&#x2F;注册后，被触发一次就失效了，只能监听一次改变。可以多次监听</span><br><span class="line">Thread.sleep(300000);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (KeeperException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;输出(此时输出的都是连上服务器触发的信息，改变节点不会再输出，需要重新监听)</span><br><span class="line">path&#x3D;null</span><br><span class="line">eventType&#x3D;None</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">zookeeper简单操作</summary>
    
    
    
    <category term="zookeeper" scheme="http://zhaojun.me/categories/zookeeper/"/>
    
    
    <category term="zookeeper" scheme="http://zhaojun.me/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型与线程</title>
    <link href="http://zhaojun.me/2017/10/17/JVM-memory-model/"/>
    <id>http://zhaojun.me/2017/10/17/JVM-memory-model/</id>
    <published>2017-10-17T03:52:59.000Z</published>
    <updated>2017-10-23T15:26:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、硬件效率与一致性"><a href="#1、硬件效率与一致性" class="headerlink" title="1、硬件效率与一致性"></a>1、硬件效率与一致性</h3><p>由于计算机的存储设备与处理器的运算速度有几个数量级的差距，现在计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存(Cache)来作为内存与处理器之间的缓冲：将需要用到的数据复制到缓存中，让运算快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。然而，因为每个处理器有自己的高速缓存，而它们又共享同一主内存，因此多处理器运算会导致各自缓存数据不一致，因此就需要遵循一些协议来访问缓存。  </p><img src="/2017/10/17/JVM-memory-model/a.jpeg" class="" title="图1"> <p>除了增加高速缓存外，为了使得处理器内部的运算单元能尽量被充分使用，处理器可能会对输入的代码进行乱序优化。但是会保证执行结果与顺序执行是一致的，但不保证程序中各个语句计算的先后顺序与输入代码的顺序一致。Java虚拟机的即时编译器也有类似的指令重排序优化。</p><h3 id="2、Java内存模型"><a href="#2、Java内存模型" class="headerlink" title="2、Java内存模型"></a>2、Java内存模型</h3><p>Java内存模型主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与Java编程中的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的。不会被共享，自然不存在竞争问题。</p><p>Java内存模型规定所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了被线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取、赋值等)都必须在工作内存中进行，而不能直接读写主内存的变量。不同线程之间也无法直接访问对方工作内存的变量，线程间的变量值的传递均需要通过主内存来完成。三者关系如下：</p><img src="/2017/10/17/JVM-memory-model/b.jpeg" class="" title="图2"> <h3 id="2、内存间的交互操作"><a href="#2、内存间的交互操作" class="headerlink" title="2、内存间的交互操作"></a>2、内存间的交互操作</h3><p>Java没存模型定义了八种操作来完成工作内存与主内存间的操作，虚拟机必须保证每一种操作都是原子的、不可再分的(double与long类型的变量，load、store、read、write操作在某些平台上允许有例外，见后续)</p><ul><li>lock(锁定):作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li><li>unlock(解锁)：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才能被其他线程锁定</li><li>read(读取)：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li>load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中</li><li>use(使用)：作用于工作内存的变量，它把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用到的变量的值的字节码就会执行这个操作</li><li>assign(赋值)：作用于工作内存的变量，它把一个执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个需要使用到变量赋值的字节码指令时将会执行这个操作</li><li>store(存储)：作用于工作内存的变量，它把工作内存中的一个变量值传送到主内存中，以便随后的write操作使用</li><li>write(写入)：作用于主内存的变量，它把store操作从工作内存中得到变量的值放入主内存变量中</li></ul><p>如果要把一个变量从主内存复制到工作内存，那就要顺序的执行read和load操作，如果要同步回主内存，就要顺序执行store和write操作。注意是顺序，不必连续。除此之外。还有如下规则：</p><ul><li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但是工作内存不接受，或者从工作内存发起了回写但是主内存不接受的情况出现。</li><li>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须同步回主内存。</li><li>不允许一个线程无原因地(没有发生过任何assign操作)把数据从线程的工作内存同步回主内存</li><li>一个变量只能在主内存中诞生。不允许在工作内存中直接使用未被初始化(load或assign)的变量，就是对一个变量实施use、store之前必须assign和load操作</li><li>一个变量同一时刻只允许一条线成lock操作</li><li>如果对一个变量执行lock操作，那将会清空工作内存中的此变量的值，在执行引擎使用这个变量钱，需要重新load和assign</li><li>如果一个变量没有lock，那么不允许对它unlock，也不允许unlock一个被其他线程锁定住的变量</li><li>执行lock之前，必须将此变量 同步回主内存(store和write)<br>另外对于volatile修饰的变量，当一个线程修改了改变量的值，会立即更新主存，并且其他线程看到该修饰符，会每次从主存来读而不是使用自己的缓存。因次就会每次读到最新的值。  </li></ul><p>对于64位的数据类型(long和double)，允许虚拟机对没有volatile修饰的64位数据的读写操作分为两次32位的操作来进行。这点就是所谓的long和double的非原子性协定。如果多个线程共享一个未声明为volatile的long或者double型变量，并同时对它们进行读写操作，可能会读取到一个既非原值，也不是其他线程修改值的代表了”半个变量”的数值，但是目前虚拟机都选择把64位数据的读写操作作为原子操作来对待，因此写代码时不需要专门声明为volatile。</p><h3 id="3、先行发生-happens-before-原则"><a href="#3、先行发生-happens-before-原则" class="headerlink" title="3、先行发生(happens-before)原则"></a>3、先行发生(happens-before)原则</h3><p>先行发生原则就是如果A先行发生与操作B(就是A发生在B之前)，那么操作A产生的影响都能被操作B观察到，”影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。规定如下：</p><ul><li>程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于后面的操作(注意先行发生的定义，是影响会被观察到，没影响另说)。</li><li>管程锁定规则：一个unlock操作先行发生于后面对同一个锁的locak操作。”后面”是时间的先后顺序</li><li>volatile变量原则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。”后面”指时间的先后顺序</li><li>线程启动规则： Thread对象的start()方法先行发生于此线程的每一个动作</li><li>线程终止规则：线程所有操作都先行发生于此线程的终止检测。可以通过Thread.join()方法结束、Thread.isAlive()返回值等手段检测线程已经终止进行</li><li>线程终端规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生</li><li>对象终结规则：一个对象的初始化完成(构造函数执行结束)先行于它的finalize()方法的开始</li><li>传递性：如果A先行发生于B，B先行发生于C，那么A先行发生与C</li></ul><p>需要注意的是，先行发生跟时间上的先后发生没啥关系，先行发生只是表明，A的影响会被B给观察到。例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;以下操作在同一线程中执行</span><br><span class="line">int i &#x3D; 1;&#x2F;&#x2F;操作1</span><br><span class="line">int j &#x3D; 2;&#x2F;&#x2F;操作2</span><br></pre></td></tr></table></figure><p>根据程序次序规则，操作1先行发生于操作2，但是操作2的代码完全可能被处理器先执行(因为指令重排序)，这并不影响先行发生原则的正确性，因为这条线程中，这俩赋值语句没啥互相影响。</p>]]></content>
    
    
    <summary type="html">理解Java中多线程</summary>
    
    
    
    <category term="Jvm" scheme="http://zhaojun.me/categories/Jvm/"/>
    
    
    <category term="Jvm" scheme="http://zhaojun.me/tags/Jvm/"/>
    
  </entry>
  
  <entry>
    <title>Java异常</title>
    <link href="http://zhaojun.me/2017/09/24/Java-Exception/"/>
    <id>http://zhaojun.me/2017/09/24/Java-Exception/</id>
    <published>2017-09-24T05:18:49.000Z</published>
    <updated>2017-10-31T15:34:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>异常情形是指阻止当前方法或作用域继续执行的问题。把异常情形和普通问题区分开来很重要，所谓普通问题是指，在当前环境下能得到足够的信息，总能处理这个错误。而对于异常情形，就不能继续下去了，因为在当前环境下无法获得必要的信息来解决问题</p><p>当抛出异常后，有几件事会随之发生。首先，同Java其他对象的创建一样，将使用new在堆上创建对异常对象的引用。然后，当前的执行路径被终止，并且从当前的环境中弹出对异常对象的引用。此时异常处理机制接管程序，并开始寻找一个恰当的地方来继续执行程序。这个恰当的地方救市异常处理程序，它的任务就是将程序从错误的状态中恢复，以使程序能要么换一种方式执行，要么继续运行下去。</p><h3 id="2、异常的类型"><a href="#2、异常的类型" class="headerlink" title="2、异常的类型"></a>2、异常的类型</h3><p>异常主要分为以下几种类型，只有Exception下得非RuntimeException需要我们在方法上声明throws异常或者使用try／catch进行处理。当然也可以使用throws声明异常，但是不抛出异常。这样的好处是为异常先占个位置，以后就可以抛出异常而不用修改已有的代码。在定义抽象基类和接口时这种能力极为重要。</p><img src="/2017/09/24/Java-Exception/a.jpeg" class="" title="图2-1">  <h3 id="3、捕获异常"><a href="#3、捕获异常" class="headerlink" title="3、捕获异常"></a>3、捕获异常</h3><h4 id="3-1、常用方法"><a href="#3-1、常用方法" class="headerlink" title="3.1、常用方法"></a>3.1、常用方法</h4><p>Exception类很简洁，我们可以使用它从Throwable继承的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String getMessage()  &#x2F;&#x2F;获取异常信息</span><br><span class="line">String getLocalizedMessage() &#x2F;&#x2F;用本地语言表示的异常信息</span><br><span class="line"></span><br><span class="line">String toString()  &#x2F;&#x2F;返回对Throwable的简单描述，要是有详细信息的话，也会把它包含在内</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印Throwable和Throwable的调用栈轨迹。调用栈显示了“把你带到异常抛出地点的方法调用轨迹”</span><br><span class="line">void printStackTrace()    &#x2F;&#x2F;输出到标准错误</span><br><span class="line">void printStackTrace(PrintStream)   &#x2F;&#x2F;输出到特定控制流</span><br><span class="line">void printStackTrace(java.io.PrintWriter)  &#x2F;&#x2F;同上</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Throwable fillStackTrace()  &#x2F;&#x2F;用于在Throwable对象的内部记录栈帧的当前状态。这在重新抛出错误或异常时很有用</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class ExceptionsMethods &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            throw new Exception(&quot;My Exception&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;getMessage():&quot; + e.getMessage());</span><br><span class="line">            System.out.println(&quot;getLocalizedMessage():&quot; + e.getLocalizedMessage());</span><br><span class="line">            System.out.println(&quot;toString():&quot; + e.toString());</span><br><span class="line">            System.out.println(&quot;printStackTrace():&quot; );</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#x2F;&#x2F;output:</span><br><span class="line">getMessage():My Exception</span><br><span class="line">getLocalizedMessage():My Exception</span><br><span class="line">toString():java.lang.Exception: My Exception</span><br><span class="line">printStackTrace():</span><br><span class="line">java.lang.Exception: My Exception</span><br><span class="line">at com.web.tree.test.ExceptionsMethods.main(ExceptionsMethods.java:9)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)</span><br></pre></td></tr></table></figure><p>可以发现每个方法都比前一个提供更多的信息，实际上每一个都是前一个的超集。</p><h4 id="3-2、栈轨迹"><a href="#3-2、栈轨迹" class="headerlink" title="3.2、栈轨迹"></a>3.2、栈轨迹</h4><p>printStackTrace()方法所提供的信息可以使用getStackTrace()方法来直接访问，这个方法将返回一个由栈轨迹中元素所构成的数组，其中每个元素都表示栈的一帧。元素0是栈顶元素，并且是最后调用序列的最后一个方法调用，也就是异常抛出之处，如下列的f；数组的最后一个元素和栈底是调用序列的第一个方法调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class WhoCalled &#123;</span><br><span class="line">    static void f() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            throw new Exception();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            for (StackTraceElement ste : e.getStackTrace()) &#123;</span><br><span class="line">                System.out.println(ste.getMethodName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#x2F;&#x2F;output:</span><br><span class="line">f</span><br><span class="line">main</span><br><span class="line">invoke0</span><br><span class="line">invoke</span><br><span class="line">invoke</span><br><span class="line">invoke</span><br><span class="line">main</span><br></pre></td></tr></table></figure><p>这里只打印了方法名，实际上可以打印整个StackTraceElement，它包含了其他附件信息。</p><h4 id="3-3、重新抛出异常"><a href="#3-3、重新抛出异常" class="headerlink" title="3.3、重新抛出异常"></a>3.3、重新抛出异常</h4><p>有时候希望把捕获的异常重新抛出，如果已经捕获了当前异常的引用，那么直接抛出即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">catch(Exception e) &#123;</span><br><span class="line">    System.out.println(&quot;An exception was thrown&quot;);</span><br><span class="line">    throw e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新抛出异常会把异常抛给上一级环境中的异常处理程序，同一个try块后续的catch将会被忽略。此外，异常对象的所有信息都得以保持，所以高一级的环境中捕获此异常的处理程序可以从这个异常对象中得到所有信息。</p><p>如果只是将当前异常对象重新抛出，那么使用printStackTrace方法就可以。要想更新这个信息，可以调用fillInStackTrace方法，这会返回一个Throwable对象，它通过将当前调用栈的信息填入原来那个异常对象而建立的，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public class Rethrowing &#123;</span><br><span class="line">    public static void f() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;Exception in f()&quot;);</span><br><span class="line">        throw new Exception(&quot;throw from f()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void g() throws Exception &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            f();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;Inside g()&quot;);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void h() throws Exception &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            f();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;Inside h()&quot;);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw (Exception) e.fillInStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            g();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;main:&quot;);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;-------------------&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            h();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;main:&quot;);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">Exception in f()</span><br><span class="line">Inside g()</span><br><span class="line">java.lang.Exception: throw from f()</span><br><span class="line">at com.web.tree.test.Rethrowing.f(Rethrowing.java:9)</span><br><span class="line">at com.web.tree.test.Rethrowing.g(Rethrowing.java:14)</span><br><span class="line">at com.web.tree.test.Rethrowing.main(Rethrowing.java:33)</span><br><span class="line">main:</span><br><span class="line">java.lang.Exception: throw from f()</span><br><span class="line">at com.web.tree.test.Rethrowing.f(Rethrowing.java:9)</span><br><span class="line">at com.web.tree.test.Rethrowing.g(Rethrowing.java:14)</span><br><span class="line">at com.web.tree.test.Rethrowing.main(Rethrowing.java:33)</span><br><span class="line">-------------------</span><br><span class="line">Exception in f()</span><br><span class="line">Inside h()</span><br><span class="line">main:</span><br><span class="line">java.lang.Exception: throw from f()</span><br><span class="line">at com.web.tree.test.Rethrowing.f(Rethrowing.java:9)</span><br><span class="line">at com.web.tree.test.Rethrowing.h(Rethrowing.java:24)</span><br><span class="line">at com.web.tree.test.Rethrowing.main(Rethrowing.java:40)</span><br><span class="line">java.lang.Exception: throw from f()</span><br><span class="line">at com.web.tree.test.Rethrowing.h(Rethrowing.java:28)&#x2F;&#x2F;这里重新定义了抛出地点，没有原来的抛出信息</span><br><span class="line">at com.web.tree.test.Rethrowing.main(Rethrowing.java:40)</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>调用fillInStackTrace成为了新的异常发生地。有可能在捕获之后抛出另外一种异常，这么做有点类似于fillInStackTrace，有关原来发生的异常信息发生点会丢失，剩下的是与新抛出的地点有关的信息。另外，不必为清理前一个异常对象而担心，或者说为异常对象的清理而担心。它们都是在堆上用new创建的对象，所以垃圾回收器会自动把它清理掉。</p><h4 id="3-4、异常链"><a href="#3-4、异常链" class="headerlink" title="3.4、异常链"></a>3.4、异常链</h4><p>常常需要在捕获一个异常后想要抛出另外一个异常，并且希望保存原来的异常信息，这被成为异常链。可以使用Throwable子类构造器参数为cause对象为参数，这个cause就用来表示原有异常，这样就通过把原始异常传递给新的异常。</p><p>但是在Throwable子类中，只有三种基本异常类提供了待cause参数的构造器，分别是Error，RuntimeException，Exception。如果要把其他类型的异常连接起来，应该使用initCause（）方法而不是构造器。</p><h3 id="4、异常的限制"><a href="#4、异常的限制" class="headerlink" title="4、异常的限制"></a>4、异常的限制</h3><p>当覆盖方法的时候，只能抛出在基类方法的异常说明里列出的那些异常。这个限制很有用，当基类使用的代码应用到其派生类对象的时候，一样能工作。</p><p>参考自《Java编程思想》</p>]]></content>
    
    
    <summary type="html">异常情形是指阻止当前方法或作用域继续执行的问题。</summary>
    
    
    
    <category term="Java" scheme="http://zhaojun.me/categories/Java/"/>
    
    
    <category term="Java" scheme="http://zhaojun.me/tags/Java/"/>
    
    <category term="异常" scheme="http://zhaojun.me/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper1</title>
    <link href="http://zhaojun.me/2017/09/24/zookeeper1/"/>
    <id>http://zhaojun.me/2017/09/24/zookeeper1/</id>
    <published>2017-09-24T05:18:49.000Z</published>
    <updated>2017-11-06T14:44:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、数据结构"><a href="#1、数据结构" class="headerlink" title="1、数据结构"></a>1、数据结构</h3><p>简单的说，zookeeper=数据结构+通知机制。其中数据结构跟文件系统的目录很相似：</p><img src="/2017/09/24/zookeeper1/a.jpeg" class="" title="图1-1">  <p>树形结构中每个节点称为Znode，跟文件系统不同的是，每个Znode可以存储数据，数据大小可以在配置文件中配置，默认最大不超过1M。另外，可以对节点进行增加子节点，删除节点，修改数据等操作，并且Zookeeper能通知客户端节点发生了变化，这就是通知机制。节点共有四种类型：</p><ul><li>PERSISTENT-持久化目录节点：客户端与zookeeper断开连接后，该节点依旧存在</li><li>PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点：客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号(就是名称后面会加一组排序的数字)</li><li>EPHEMERAL-临时目录节点：客户端与zookeeper断开连接后，该节点被删除</li><li>EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点：客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号</li></ul><h3 id="2、使用场景"><a href="#2、使用场景" class="headerlink" title="2、使用场景"></a>2、使用场景</h3><h4 id="2-1、数据发布／订阅"><a href="#2-1、数据发布／订阅" class="headerlink" title="2.1、数据发布／订阅"></a>2.1、数据发布／订阅</h4><p>发布者将数据发布到zk的一个或者一系列节点，订阅者进行数据订阅，当数据有变化时，Zookeeper通过通知机制讲数据通知给订阅者。</p><h4 id="2-2、负载均衡-非主要"><a href="#2-2、负载均衡-非主要" class="headerlink" title="2.2、负载均衡(非主要)"></a>2.2、负载均衡(非主要)</h4><p>利用zookeeper的配置管理功能，步骤如下：  </p><ul><li>1.服务提供者把自己的域名及ip端口的映射注册到zk中 </li><li>2.服务消费者通过域名从zk中获取到对应的ip及端口，这个ip及端口有多个，获取其中一个 </li><li>3.当服务提供者宕机时，对应的域名IP的对应就会减少一个映射，这样就始终获取到有效的映射，就能进行负载均衡了</li></ul><h4 id="2-3、命名服务"><a href="#2-3、命名服务" class="headerlink" title="2.3、命名服务"></a>2.3、命名服务</h4><p>分布式应用中，通常需要有一套完整的命名规则，既能够产生唯一的名称又便于人识别和记住，通常情况下用树形的名称结构是一个理想的选择，树形的名称结构是一个有层次的目录结构，既对人友好又不会重复。说到这里你可能想到了JNDI，没错Zookeeper的Name Service与JNDI能够完成的功能是差不多的，它们都是将有层次的目录结构关联到一定资源上，但是Zookeeper的Name Service更加是广泛意义上的关联，也许你并不需要将名称关联到特定资源上，你可能只需要一个不会重复名称，就像数据库中产生一个唯一的数字主键一样。</p><h4 id="2-4、配置管理"><a href="#2-4、配置管理" class="headerlink" title="2.4、配置管理"></a>2.4、配置管理</h4><p>程序总是需要配置的，如果程序分散部署在多台机器上，要逐个改变配置就变得困难。把这些配置全部放到zookeeper上去，保存在Zookeeper的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序就会收到Zookeeper的通知，然后从Zookeeper获取新的配置信息应用到系统中就好。</p><img src="/2017/09/24/zookeeper1/b.jpeg" class="" title="图2-1">  <h4 id="2-5、集群管理"><a href="#2-5、集群管理" class="headerlink" title="2.5、集群管理"></a>2.5、集群管理</h4><p>所谓集群管理无在乎两点：是否有机器退出和加入、选举master。<br>对于第一点，所有机器约定在父目录GroupMembers下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与zookeeper的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道：它上船了。新机器加入也是类似，所有机器收到通知：新兄弟目录加入，highcount又有了。<br>对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为master就好。</p><img src="/2017/09/24/zookeeper1/c.jpeg" class="" title="图2-2">  <h4 id="2-6、分布式锁"><a href="#2-6、分布式锁" class="headerlink" title="2.6、分布式锁"></a>2.6、分布式锁</h4><p>有了zookeeper的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序。</p><p>对于第一类，我们将zookeeper上的一个znode看作是一把锁，通过createznode的方式来实现。所有客户端都去创建同一个目录节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的目录节点就释放出锁。</p><p>对于第二类， 如果目录节点已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选master一样，编号最小的获得锁，用完删除，依次方便。</p><h4 id="2-7、队列"><a href="#2-7、队列" class="headerlink" title="2.7、队列"></a>2.7、队列</h4><p>两种类型的队列：</p><ul><li>同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。</li><li>队列按照FIFO方式进行入队和出队操作。</li></ul><p>第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号(前文中的顺序编号节点，带有顺序)。</p><h3 id="3、基本概念"><a href="#3、基本概念" class="headerlink" title="3、基本概念"></a>3、基本概念</h3><h4 id="3-1、集群角色"><a href="#3-1、集群角色" class="headerlink" title="3.1、集群角色"></a>3.1、集群角色</h4><p>当使用zookeeper搭建集群时，有三种角色：</p><ul><li>Leader：为客户端提供读和写服务</li><li>Follower：提供读服务，写服务会转交给Leader，参与选举Observer </li><li>Observer：跟Follower的区别是不参与投票，一般是为了增强zk集群的读请求并发能力</li></ul><p>结构图如下：</p><img src="/2017/09/24/zookeeper1/d.jpeg" class="" title="图3-1">  <h4 id="3-2、会话-session"><a href="#3-2、会话-session" class="headerlink" title="3.2、会话(session)"></a>3.2、会话(session)</h4><p>客户端向服务端的请求连接。通过心跳检测保持客户端连接的存活。接收来自服务端的watch事件通知。</p><h4 id="3-2、版本"><a href="#3-2、版本" class="headerlink" title="3.2、版本"></a>3.2、版本</h4><p>每个节点都会有一个版本的属性，操作节点时，版本号会+1，有点类似与mysql中的记录版本号。</p><ul><li>Version：当前Znode的版本</li><li>Cversion：当前Znode子节点版本</li><li>Aversion：当前Znode的ACl版本<br>ACL(Access Control Lists)代表节点的权限控制，类似于linux/unix的权限控制</li><li>CREATE：创建子节点的权限</li><li>READ:获取节点数据和子节点列表的权限</li><li>WRITE 更新节点数据的权限</li><li>DELETE：删除子节点的权限</li><li>ADMIN：设置节点ACL的权限</li></ul>]]></content>
    
    
    <summary type="html">zookeeper是一个高性能、开源分布式应用协调服务</summary>
    
    
    
    <category term="zookeeper" scheme="http://zhaojun.me/categories/zookeeper/"/>
    
    
    <category term="zookeeper" scheme="http://zhaojun.me/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Java注解</title>
    <link href="http://zhaojun.me/2017/09/24/Java-Annotation/"/>
    <id>http://zhaojun.me/2017/09/24/Java-Annotation/</id>
    <published>2017-09-24T04:47:26.000Z</published>
    <updated>2017-10-25T12:49:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过注解，我们可以使代码更加干净易读，可以在编译期进行类型检查。同时我们可以将元数据保存在Java源代码中，利用annotation api为自己的注解构造处理工具。</p><h3 id="1、元注解"><a href="#1、元注解" class="headerlink" title="1、元注解"></a>1、元注解</h3><p>java有四种元注解，专门负责注解其他的注解：</p><ul><li>@Target:表示该注解可以用在什么地方，比如类上面，或者方法构造器等等</li><li>@Retention: 表示在什么级别保存注解信息。比如源码文件或者class文件、运行期间。</li><li>@Documented: 表示生成Javadoc时，包括该注解。</li><li>@Inherited: 表示子类继承父类中的注解。 </li></ul><p>大多时候，我们都需要定义自己的注解，并编写代码来处理。</p><h3 id="2、默认值的限制"><a href="#2、默认值的限制" class="headerlink" title="2、默认值的限制"></a>2、默认值的限制</h3><p>编译器对元素的默认值有些过分挑剔。首先元素不能有不确定的值。也就是说，元素必须要么具有默认值，要么在使用注解时提供元素的值。</p><p>其实对于非基本类型的元素，无论是在源代码中声明时，或是在注解接口中定义默认值时，都不能以null作为其值。为了绕开这个约束，我们只能自己定义一些特殊的值，例如空字符串或者负数，来表示这个值不存在。</p><h3 id="3、示例"><a href="#3、示例" class="headerlink" title="3、示例"></a>3、示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义注解</span><br><span class="line">package annotations;</span><br><span class="line">import java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line">@Target(ElementType.METHOD) &#x2F;&#x2F;方法级别的注解</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME) &#x2F;&#x2F;在运行期间使用</span><br><span class="line">public @interface UseCase &#123;</span><br><span class="line">  public int id();  &#x2F;&#x2F;属性1</span><br><span class="line">  public String description() default &quot;no description&quot;; &#x2F;&#x2F;属性2</span><br><span class="line">&#125; &#x2F;&#x2F;&#x2F;:~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用注解</span><br><span class="line">package annotations; </span><br><span class="line">import java.lang.reflect.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class UseCaseTracker &#123;</span><br><span class="line">  public static void trackUseCases(List&lt;Integer&gt; useCases, Class&lt;?&gt; cl) &#123;</span><br><span class="line">    for(Method m : cl.getDeclaredMethods()) &#123; &#x2F;&#x2F;反射拿到所有的方法</span><br><span class="line">      UseCase uc &#x3D; m.getAnnotation(UseCase.class);  &#x2F;&#x2F;拿到方法级别上的注解，然后就可以使用注解里的属性了</span><br><span class="line">      if(uc !&#x3D; null) &#123; &#x2F;&#x2F;存在注解时</span><br><span class="line">        System.out.println(&quot;Found Use Case:&quot; + uc.id() + &#x2F;&#x2F;属性1</span><br><span class="line">          &quot; &quot; + uc.description());     &#x2F;&#x2F;属性2</span><br><span class="line">        useCases.remove(new Integer(uc.id()));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i : useCases) &#123;</span><br><span class="line">      System.out.println(&quot;Warning: Missing use case-&quot; + i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; useCases &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">    Collections.addAll(useCases, 47, 48, 49, 50);</span><br><span class="line">    trackUseCases(useCases, PasswordUtils.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; &#x2F;* Output:</span><br><span class="line">Found Use Case:47 Passwords must contain at least one numeric</span><br><span class="line">Found Use Case:48 no description</span><br><span class="line">Found Use Case:49 New passwords can&#39;t equal previously used ones</span><br><span class="line">Warning: Missing use case-50</span><br><span class="line">*&#x2F;&#x2F;&#x2F;:~</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java注解基础知识</summary>
    
    
    
    <category term="Java" scheme="http://zhaojun.me/categories/Java/"/>
    
    
    <category term="Java" scheme="http://zhaojun.me/tags/Java/"/>
    
    <category term="注解" scheme="http://zhaojun.me/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java获取泛型类型</title>
    <link href="http://zhaojun.me/2017/09/09/Java-generics/"/>
    <id>http://zhaojun.me/2017/09/09/Java-generics/</id>
    <published>2017-09-09T03:37:59.000Z</published>
    <updated>2017-10-24T13:03:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java泛型有这么一种规律：</p><ul><li>位于声明一侧的，源码里写了什么到运行时就能看到什么； </li><li>位于使用一侧的，源码里写什么到运行时都没了。 </li></ul><p>什么意思呢？“声明一侧”包括泛型类型（泛型类与泛型接口）声明、带有泛型参数的方法和域的声明。注意局部变量的声明不算在内，那个属于“使用”一侧。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.util.List;  </span><br><span class="line">import java.util.Map;  </span><br><span class="line">  </span><br><span class="line">public class GenericClass&lt;T&gt; &#123;                &#x2F;&#x2F; 1  </span><br><span class="line">    private List&lt;T&gt; list;                     &#x2F;&#x2F; 2  </span><br><span class="line">    private Map&lt;String, T&gt; map;               &#x2F;&#x2F; 3  </span><br><span class="line">      </span><br><span class="line">    public &lt;U&gt; U genericMethod(Map&lt;T, U&gt; m) &#123; &#x2F;&#x2F; 4  </span><br><span class="line">        return null;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">进入文件目录下使用命令javac Test.java编译，然后会生成字节码(.class)文件，再使用命令javap -verbose Test反编译打开：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码里，带有注释的行里的泛型信息在运行时都还能获取到，原则是源码里写了什么运行时就能得到什么。针对1的GenericClass<T>，运行时通过Class.getTypeParameters()方法得到的数组可以获取那个“T”；同理，2的T、3的java.lang.String与T、4的T与U都可以获得。源码文本里写的是什么运行时就能得到什么；像是T、U等在运行时的实际类型是获取不到的。 </p><p>这是因为从Java 5开始class文件的格式有了调整，规定这些泛型信息要写到class文件中。以上面的map为例，通过javap来看它的元数据可以看到记录了这样的信息： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private java.util.Map map;  </span><br><span class="line">  Signature: Ljava&#x2F;util&#x2F;Map;  </span><br><span class="line">  Signature: length &#x3D; 0x2  </span><br><span class="line">   00 0A  </span><br></pre></td></tr></table></figure><p>乍一看，private java.util.Map map;不正好显示了它的泛型类型被擦除了么？   </p><p>但仔细看会发现有两个标签(Signature)，下面的一个有两字节的数据，0x0A。到常量池找到0x0A对应的项，是： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const #10 &#x3D; Asciz       Ljava&#x2F;util&#x2F;Map&lt;Ljava&#x2F;lang&#x2F;String;TT;&gt;;;  </span><br></pre></td></tr></table></figure><p>也就是内容为<code>Ljava/util/Map&lt;Ljava/lang/String;TT;&gt;;</code>的一个字符串。   </p><p>根据Java 5开始的新class文件格式规范，方法与域的描述符增添了对泛型信息的记录，用一对尖括号包围泛型参数，其中普通的引用类型用“La/b/c/D;”的格式记录，未绑定值的泛型变量用“Txxx;”的格式记录，其中xxx就是源码中声明的泛型变量名。类型声明的泛型信息也以类似下面的方式记了下来： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class GenericClass extends java.lang.Object  </span><br><span class="line">  Signature: length &#x3D; 0x2  </span><br><span class="line">   00 12  </span><br><span class="line">&#x2F;&#x2F; ...  </span><br><span class="line">const #18 &#x3D; Asciz       &lt;T:Ljava&#x2F;lang&#x2F;Object;&gt;Ljava&#x2F;lang&#x2F;Object;;  </span><br></pre></td></tr></table></figure><p>相比之下，“使用一侧”的泛型信息则完全没有被保留下来，在Java源码编译到class文件后就确实丢失了。也就是说，在方法体内的泛型局部变量、泛型方法调用之类的泛型信息编译后都消失了。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;  </span><br><span class="line">import java.util.List;  </span><br><span class="line">  </span><br><span class="line">public class TestClass &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        List&lt;String&gt; list &#x3D; null;       &#x2F;&#x2F; 1  </span><br><span class="line">        list &#x3D; new ArrayList&lt;String&gt;(); &#x2F;&#x2F; 2  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>上面代码中，1留下的痕迹是：main()方法的StackMapTable属性里可以看到： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StackMapTable: number_of_entries &#x3D; 2  </span><br><span class="line"> frame_type &#x3D; 253 &#x2F;* append *&#x2F;  </span><br><span class="line">   offset_delta &#x3D; 12  </span><br><span class="line">   locals &#x3D; [ class java&#x2F;util&#x2F;List, int ]  </span><br><span class="line"> frame_type &#x3D; 250 &#x2F;* chop *&#x2F;  </span><br><span class="line">   offset_delta &#x3D; 11  </span><br></pre></td></tr></table></figure><p>但这里是没有留下泛型信息的。这段代码只所以写了个空的for循环就是为了迫使javac生成那个StackMapTable，让1多留个影。当整个方法只有一个基本块的时候javac就不会生成StackMapTable属性，就看不到这可爱的数据结构了。<br>如果main()里用到了list的方法，那么那些方法调用点上也会留下1的痕迹，例如如果调用list.add(“”);，则会留下“java/util/List.add:(Ljava/lang/Object;)Z”这种记录。<br>2留下的是“java/util/ArrayList.”<init>“:()V”，同样也丢失了泛型信息。   </p><p>由上述讨论可知，想对带有未绑定的泛型变量的泛型类型获取其实际类型是不现实的，因为class文件里根本没记录实际类型的信息。觉得这句话太拗口的话用例子来理解：要想对java.util.List<E>获取E的实际类型是不现实的，因为List.class文件里只记录了E，却没记录使用List<E>时E的实际类型。因为只有将泛型具体化才能拿到相应的特定类型。</p><p>想对局部变量等“使用一侧”的已绑定的泛型类型获取其实际类型也不现实，同样是因为class文件中根本没记录这个信息。例子直接看上面讲“使用一侧”的就可以了。 </p><p>知道了什么信息有记录，什么信息没有记录之后，也就可以省点力气不去纠结“拿不到T的实际类型”、“建不出T类型的数组”、“不能对T类型做instanceof”之类的问题了orz</p><p>转自：<a href="http://rednaxelafx.iteye.com/blog/586212">http://rednaxelafx.iteye.com/blog/586212</a></p>]]></content>
    
    
    <summary type="html">获取泛型类型</summary>
    
    
    
    <category term="Java" scheme="http://zhaojun.me/categories/Java/"/>
    
    
    <category term="Java" scheme="http://zhaojun.me/tags/Java/"/>
    
    <category term="泛型" scheme="http://zhaojun.me/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>springmvc记录一次坑</title>
    <link href="http://zhaojun.me/2017/09/09/Springmvc-bug/"/>
    <id>http://zhaojun.me/2017/09/09/Springmvc-bug/</id>
    <published>2017-09-09T03:37:59.000Z</published>
    <updated>2017-10-24T12:58:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用postman测试post请求接口时(写js也一样)，可以选择form-data或者x-www-form-urlencoded两种模式，当然还有其他选择。其中form-data模式对应着Content-Type: multipart/form-data，可以上传文件。而x-www-form-urlencoded对应着Content-Type: application/x-www-form-urlencoded，即普通的表单上传，不支持文件。</p><p>当使用form-data模式时，需要在SpringMvc配置文件里加上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;multipartResolver&quot; class&#x3D;&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><p>从而支持文件上传，没有这个类，使用该模式提交普通的表单数据时会导致post请求一直接收不到参数。初始化该类只有，就可用该模式一样上传普通表单数据了。</p><p>另外，该类需要引入jar包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-fileupload&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-fileupload&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记springMvc的一次坑</summary>
    
    
    
    <category term="bug" scheme="http://zhaojun.me/categories/bug/"/>
    
    
    <category term="springmvc" scheme="http://zhaojun.me/tags/springmvc/"/>
    
    <category term="bug" scheme="http://zhaojun.me/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>Jvm垃圾收集与内存分配</title>
    <link href="http://zhaojun.me/2017/09/09/JVM-GC/"/>
    <id>http://zhaojun.me/2017/09/09/JVM-GC/</id>
    <published>2017-09-09T03:37:59.000Z</published>
    <updated>2017-11-04T08:30:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、回收对象"><a href="#1、回收对象" class="headerlink" title="1、回收对象"></a>1、回收对象</h3><h4 id="1-1、引用计数法"><a href="#1-1、引用计数法" class="headerlink" title="1.1、引用计数法"></a>1.1、引用计数法</h4><p>给对象添加一个引用计数器，每有一个地方引用它时，计数器就+1,；当引用失效时，计数器-1；任何时刻计数器为0的对象就是要被回收的。</p><p>虽然引用计数器实现简单，判定效率也很高，在大部分时候是一个不错的算法，但是在主流的Java虚拟机里却没用使用这种算法来管理内存，因为它很难解决相互引用的问题。比如下面例子中，objA.instance = objB及objB.instance = objA。除此之外，这两个对象再无相互引用，实际上这两个对象已经不可能再被访问，但是他们互相引用着对方，导致引用计数都不为0，于是使用引用计数法无法回收。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class ReferenceCountingGC &#123;</span><br><span class="line"></span><br><span class="line">public Object instance &#x3D; null;</span><br><span class="line"></span><br><span class="line">private static final int _1MB &#x3D; 1024 * 1024;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过</span><br><span class="line"> *&#x2F;</span><br><span class="line">private byte[] bigSize &#x3D; new byte[2 * _1MB];</span><br><span class="line"></span><br><span class="line">public static void testGC() &#123;</span><br><span class="line">ReferenceCountingGC objA &#x3D; new ReferenceCountingGC();</span><br><span class="line">ReferenceCountingGC objB &#x3D; new ReferenceCountingGC();</span><br><span class="line">objA.instance &#x3D; objB;</span><br><span class="line">objB.instance &#x3D; objA;</span><br><span class="line">objA &#x3D; null;</span><br><span class="line">objB &#x3D; null;</span><br><span class="line">&#x2F;&#x2F; 假设在这行发生GC，objA和objB是否能被回收？</span><br><span class="line">System.gc();</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">testGC();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时给虚拟机配置参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2017-10-12T10:08:08.282+0800: [GC (System.gc()) [PSYoungGen: 5386K-&gt;320K(74752K)] 5386K-&gt;320K(245760K), 0.0013707 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">2017-10-12T10:08:08.284+0800: [Full GC (System.gc()) [PSYoungGen: 320K-&gt;0K(74752K)] [ParOldGen: 0K-&gt;258K(171008K)] 320K-&gt;258K(245760K), [Metaspace: 2490K-&gt;2490K(1056768K)], 0.0031321 secs] [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 74752K, used 1290K [0x000000076cb00000, 0x0000000771e00000, 0x00000007c0000000)</span><br><span class="line">  eden space 64512K, 2% used [0x000000076cb00000,0x000000076cc42a68,0x0000000770a00000)</span><br><span class="line">  from space 10240K, 0% used [0x0000000770a00000,0x0000000770a00000,0x0000000771400000)</span><br><span class="line">  to   space 10240K, 0% used [0x0000000771400000,0x0000000771400000,0x0000000771e00000)</span><br><span class="line"> ParOldGen       total 171008K, used 258K [0x00000006c6000000, 0x00000006d0700000, 0x000000076cb00000)</span><br><span class="line">  object space 171008K, 0% used [0x00000006c6000000,0x00000006c60408c0,0x00000006d0700000)</span><br><span class="line"> Metaspace       used 2496K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 268K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><p>最后<code>PSYoungGen: 320K-&gt;0K(74752K)</code>说明变成了0K，垃圾收集器清理了它们。</p><h5 id="1-1-1、理解GC日志"><a href="#1-1-1、理解GC日志" class="headerlink" title="1.1.1、理解GC日志"></a>1.1.1、理解GC日志</h5><p>尽管不同收集器的日志格式可以不同，但是虚拟机设计者为了方便用户阅读，将各个收集器的日志都维持一定的共性，因此根据一些人为确定的规则阅读即可，分析上面的日志中的第一行:</p><ul><li><code>2017-10-12T10:08:08.282+0800</code>：日期时间时区，因为配置了<code>-XX:+PrintGCDateStamps</code>参数</li><li><code>[GC(System.gc())</code>：<code>[GC</code>和<code>[Full GC</code>说明这次垃圾收集的停顿类型。有Full代表发生了Stop-The-World。<code>System.gc()</code>代表是System.gc()方法触发的。</li><li><code>[PSYoungGen</code>：PS是Parallel Scavenge垃圾收集器的简称，<code>YoungGen</code>代表发生在新生代区域的收集</li><li><code>5386K-&gt;320K(74752K)</code>：回收前该内存的使用情况-&gt;回收后该内存的使用情况(该内存总容量)</li><li><code>5386K-&gt;320K(245760K)</code>：位于方括号外面。回收前Java堆的使用情况-&gt;回收后Java堆的使用情况(Java堆总容量)</li><li><code>0.0013707 secs</code>：本次GC所花费的时间。</li><li><code>[Times: user=0.00 sys=0.00, real=0.00 secs]</code>：分别代表用户态消耗的CPU时间、内核态消耗的CPU时间和操作从开始到结束所经过的墙钟时间。墙钟时间包括各种非运算的等待耗时，如IO等待、线程阻塞。CPU时间不包括等待时间，当系统有多核时，多线程操作会叠加这些CPU时间，所以user或sys时间会超过real时间。<br>第二行日志跟第一行大部分相同，主要区别是：</li><li><code>ParOldGen</code>：PS是Parallel Scavenge垃圾收集器的简称，<code>YoungGen</code>代表发生在老年代区域的收集</li><li><code>ParOldGen</code>：PS是Parallel Scavenge垃圾收集器的简称，<code>YoungGen</code>代表发生在老年代区域的收集</li><li><code>Metaspace</code>：代表永生代，存放永久的对象，比如一些静态变量很少被卸载和收集。跟老年代是捆绑在一起的。java1.7以前永生代是<code>PermGen</code>，现在被移除了<br>Heap之后的是堆上的细分区域。</li></ul><h4 id="1-2、可达性分析算法"><a href="#1-2、可达性分析算法" class="headerlink" title="1.2、可达性分析算法"></a>1.2、可达性分析算法</h4><p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点从上往下搜索，搜索所经过的路径称为引用链，当一个GC Roots没有任何引用链相连，则证明是不可用的。现在主流实现都使用这个进行判断。</p><img src="/2017/09/09/JVM-GC/a.jpeg" class="" title="图1-2">  <p>在Java中，可作为GC Roots的对象包括下列几种：</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI(即一般说的Native方法)引用的对象</li></ul><h4 id="1-3、引用"><a href="#1-3、引用" class="headerlink" title="1.3、引用"></a>1.3、引用</h4><p>JDK1.2之后，Java对引用进行了扩充，分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)4种，这4种引用强度依次逐渐减弱。</p><ul><li>强引用：代码中普遍存在，类似于”Object obj = new Object()”这类，永远不会被回收。</li><li>软引用：描述一些还有用但不是必需的对象。在系统将要发生内存溢出之前，将把这些对象列进回收范围中进行第二次回收。如果这次回收还没有足够的内存，才会抛出异常。</li><li>弱引用：描述非必需对象。被弱引用关联的对象在下一次回收时，无论内存是否足够，都会被回收。</li><li>虚引用：又称为幽灵引用或者幻影引用，最弱的引用关系。不会影响持有该引用的对象的生存时间，也无法通过虚拟引用来取得一个对象实例，给对象设置一个虚拟引用关联的唯一目的就是在这个对象被回收时收到一个系统通知。</li></ul><h4 id="1-4、生存还是死亡"><a href="#1-4、生存还是死亡" class="headerlink" title="1.4、生存还是死亡"></a>1.4、生存还是死亡</h4><p>在可达性分析算法中不可达的对象，并非一定立即被回收，要真正回收一个对象，至少要经历两次标记过程(第一次标记后始终不会被回收)。判断不可达后，会进行第一个标记并且进行一次筛选(标记与筛选是两件事)，筛选条件是此对象是否有必要执行finalize()方法。当对象没有覆盖此方法，或者此方法没有被虚拟机调用过，虚拟机将这两种情况视为筛选不成功，就会只进行第一次标记而不回收(下次垃圾收集器回收时再进行该判断，再标记并且筛选，筛选成功执行下面，失败则标记两次进行回收)。</p><p>如果被筛选成功有必要去执行finalize()方法，那么这个对象将会放在名为F-Quene的队列中，并稍后由一个虚拟机自动建立、低优先级的Finalizer线程去执行，但并不承诺会等待它运行结束(异步)。这样做的原因是，如果一个对象finalize（）方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。Finalize()方法是对象脱逃死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，只要对象在finalize()重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class FinalizeEscapeGC &#123;</span><br><span class="line">public static FinalizeEscapeGC SAVE_HOOK &#x3D; null;</span><br><span class="line">public void isAlive() &#123;</span><br><span class="line">System.out.println(&quot;yes, i am still alive :)&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected void finalize() throws Throwable &#123;&#x2F;&#x2F;重写该方法，只会被调用一次</span><br><span class="line">super.finalize();</span><br><span class="line">System.out.println(&quot;finalize mehtod executed!&quot;);</span><br><span class="line">FinalizeEscapeGC.SAVE_HOOK &#x3D; this;&#x2F;&#x2F;关联引用，拯救自己</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) throws Throwable &#123;</span><br><span class="line">SAVE_HOOK &#x3D; new FinalizeEscapeGC();</span><br><span class="line">&#x2F;&#x2F;对象第一次成功拯救自己</span><br><span class="line">SAVE_HOOK &#x3D; null;</span><br><span class="line">&#x2F;&#x2F;调用垃圾收集器，此时会去执行该对象覆盖的finalize()方法。注释掉会很有意思</span><br><span class="line">System.gc();</span><br><span class="line">&#x2F;&#x2F; 因为Finalizer方法优先级很低，暂停0.5秒，以等待它(此时低优先级队列F-Quene有时间执行了)</span><br><span class="line">Thread.sleep(500);</span><br><span class="line">if (SAVE_HOOK !&#x3D; null) &#123;&#x2F;&#x2F;finalize()方法中关联了新的引用，所以不为null了</span><br><span class="line">SAVE_HOOK.isAlive();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;no, i am dead :(&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 下面这段代码与上面的完全相同，但是这次自救却失败了，因为finalize()只会被执行一次</span><br><span class="line">SAVE_HOOK &#x3D; null;</span><br><span class="line">System.gc();</span><br><span class="line">&#x2F;&#x2F; 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span><br><span class="line">Thread.sleep(500);</span><br><span class="line">if (SAVE_HOOK !&#x3D; null) &#123;</span><br><span class="line">SAVE_HOOK.isAlive();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;no, i am dead :(&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出：</span><br><span class="line">finalize mehtod executed!</span><br><span class="line">yes, i am still alive :)</span><br><span class="line">no, i am dead :(</span><br></pre></td></tr></table></figure><p>从结果可以看出，SAVE_HOOK对象的finalize()方法确实被GC收集器触发过，并且在被收集前成功逃脱了。注意：任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。然后finalize()方法代价高昂，不确定性大，不建议使用。</p><h3 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h3><h4 id="2-1、标记-清除算法"><a href="#2-1、标记-清除算法" class="headerlink" title="2.1、标记-清除算法"></a>2.1、标记-清除算法</h4><p>先标记出需要回收的对象，完成后进行统一回收。标记的过程如上文所述。主要有两个缺点：一是效率不高，标记和清除两个过程效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片。空间碎片太多可能导致以后要分配给较大对象时，无法找到足够的连续内存而不得不提前触发垃圾收集动作。</p><img src="/2017/09/09/JVM-GC/b.jpeg" class="" title="图2-1">  <h4 id="2-2、复制算法"><a href="#2-2、复制算法" class="headerlink" title="2.2、复制算法"></a>2.2、复制算法</h4><p>为了解决效率问题，一种称为”复制”的收集算法出现了，它将内存分为容量分为相等的两块，每次只使用其中一块。当一块用完了就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样就使得每次对整个半区进行回收，内存分配时也不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行搞笑。只是这种算法的代价是将内存缩小为原来的一半，未免太高了点。</p><img src="/2017/09/09/JVM-GC/c.jpeg" class="" title="图2-2">  <p>现代的虚拟机都使用这种算法来回收新生代，但是并不需要按照1:1分配空间，而是将内存分为一块较大的Eden空间和两块较小的Suvivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中存活的对象一次性复制到另外一块Survivor上，最后清理掉原来的两块空间。HotSpot虚拟机默认Eden:Survivor为8:1，每次只有10%会被空闲着。当然在很少的情况下，Survivor大小不够装下复制过来的存活的对象，那么这些存活的对象会直接进入老年代。详细见下文。</p><h4 id="2-3、标记-整理算法"><a href="#2-3、标记-整理算法" class="headerlink" title="2.3、标记-整理算法"></a>2.3、标记-整理算法</h4><p>复制收集算法在对象存活率较高时要进行很多的复制操作，效率会变低。并且当Survivor较小时，会被超出直接进入老年代。所以老年代中一般不会直接选用这种算法。<br>标记-整理算法跟标记-清除算法标记过程一样，但是后续不是直接对可回收对象清理，而是让所有存活对象都像一端移动，然后清理掉边界以外的内存。</p><img src="/2017/09/09/JVM-GC/d.jpeg" class="" title="图2-3">  <h4 id="2-4、分代收集算法"><a href="#2-4、分代收集算法" class="headerlink" title="2.4、分代收集算法"></a>2.4、分代收集算法</h4><p>目前虚拟机都采用分代收集算法，根据对象存活周期的不同将内存分为几块。一般把Java分为新生代和老年代，这样就可以根据各种年代采取最适当的手机算法。新生代中，每次垃圾收集都有大批对象死去，只有少量存活，就采用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间进行分配担保，就必须使用标记-清除和标记-整理算法。</p><h3 id="3、垃圾收集器"><a href="#3、垃圾收集器" class="headerlink" title="3、垃圾收集器"></a>3、垃圾收集器</h3><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java虚拟机规范中对垃圾收集器的实现并没有任何规定，因此不同厂商、不同版本的虚拟机所提供的垃圾收集器可能有很大差别。另外，新生代、老年代也根据自己的特点使用不同的收集器或者不同收集器组合使用。</p><h4 id="3-1、Serial收集器"><a href="#3-1、Serial收集器" class="headerlink" title="3.1、Serial收集器"></a>3.1、Serial收集器</h4><p>该收集器是单线程收集器，当它进行垃圾收集时，必须暂停其他所有工作线程，直到收集完毕，即”Stop-The World”。需要尽量缩短用户线程的停顿时间。特点是简单而高效。</p><h4 id="3-2、ParNew收集器"><a href="#3-2、ParNew收集器" class="headerlink" title="3.2、ParNew收集器"></a>3.2、ParNew收集器</h4><p>该收集器是Serial的多线程版本,单CPU下不会比Serial收集器效果更好，因为切换线程有额外开销。但是多核CPU是有好处的。</p><h4 id="3-3、Parallel-Scavenge收集器"><a href="#3-3、Parallel-Scavenge收集器" class="headerlink" title="3.3、Parallel Scavenge收集器"></a>3.3、Parallel Scavenge收集器</h4><p>跟ParNew差不多，特点是关注点不同，以上俩收集器目标是缩短垃圾收集时用户线程的停顿时间，该收集器目标是达到一个可控制的吞吐量。吞吐量=运行用户线程时间/(运行用户代码时间+垃圾收集时间)，提高CPU效率。</p><h4 id="3-4、Serial-Old收集器"><a href="#3-4、Serial-Old收集器" class="headerlink" title="3.4、Serial Old收集器"></a>3.4、Serial Old收集器</h4><p>Serial收集器老年代版本，单线程收集器，使用”标记-整理”算法。</p><h4 id="3-5、Parallel-Old收集器"><a href="#3-5、Parallel-Old收集器" class="headerlink" title="3.5、Parallel Old收集器"></a>3.5、Parallel Old收集器</h4><p>Parallel收集器老年代版本，使用”标记-整理”算法。</p><h4 id="3-6、CMS收集器"><a href="#3-6、CMS收集器" class="headerlink" title="3.6、CMS收集器"></a>3.6、CMS收集器</h4><p>以获取最短回收停顿时间为目标，”标记-清除”算法。</p><h4 id="3-7、G1收集器"><a href="#3-7、G1收集器" class="headerlink" title="3.7、G1收集器"></a>3.7、G1收集器</h4><p>新生收集器</p><h3 id="4、内存分配与回收策略"><a href="#4、内存分配与回收策略" class="headerlink" title="4、内存分配与回收策略"></a>4、内存分配与回收策略</h3><p>Java技术体系所提倡的自动内存管理可以归结为自动化解决两个问题：给对象分配内存以及回收分配给对象的内存。对象内存分配的规则并不是固定的，取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关参数的设置。接下来有几条普遍的规则，并且使用代码验证，是在Serial/Serial Old收集器下(ParNew/Serial Old组合也基本一致)收集器下的内存分配和回收策略，有兴趣也可以研究其他收集器下的分配策略。</p><h4 id="4-1、对象优先在Eden分配"><a href="#4-1、对象优先在Eden分配" class="headerlink" title="4.1、对象优先在Eden分配"></a>4.1、对象优先在Eden分配</h4><p>大多数情况下，对象在新生代Eden分配。当Eden区没有足够的空间分配时，虚拟机发起一次Minor GC(指发生在新生代的垃圾收集动作)。虚拟机提供-XX:PrintDCDetails这个参数，告诉虚拟机发生垃圾收集行为时打印日志，并在进程退出时输出当前内存区域分配情况。</p><h4 id="4-2、大对象直接进入老年代"><a href="#4-2、大对象直接进入老年代" class="headerlink" title="4.2、大对象直接进入老年代"></a>4.2、大对象直接进入老年代</h4><p>所谓的大对象是指需要大量连续内存空间的Java对象，最典型的是那种很长的字符串和数组。大对象对虚拟机内存分配来说是一个坏消息(更坏的是一堆很快不用，需要回收的大对象，写程序应尽量避免)，经常出现大对象会导致内存还有不少空间时就提前出发垃圾收集以获取足够连续空间来存储它们。虚拟提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。</p><h4 id="4-3、长期存活的对象将进入老年代"><a href="#4-3、长期存活的对象将进入老年代" class="headerlink" title="4.3、长期存活的对象将进入老年代"></a>4.3、长期存活的对象将进入老年代</h4><p>虚拟机采用分代收集的思想来管理内存，那么内存回收时就能识别哪些对象应放在新生代，哪些对象应放在老年代。为了做到这点，虚拟机给每个对象定义了一个对象年龄的计数器。如果对象在Eden出生后并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移到Survivor空间中，并且将对象年龄设为1。对象在Survivor区每经过一次Minor GC，年龄就增加一岁，当年龄增加到一定程度(默认15岁)，就会被晋升到老年代中。对象晋升老年代的阀值，可通过-XX:MaxTenuringThreshold设置。</p><p>另外为了更好适应各种状况，如果Survivor中相同年龄的所有对象大小和大于该空间的一半，年龄大于等于该年龄的对象就能直接进入老年代，无须等到要求的年龄。</p>]]></content>
    
    
    <summary type="html">Jvm内存分配及收集内存</summary>
    
    
    
    <category term="Jvm" scheme="http://zhaojun.me/categories/Jvm/"/>
    
    
    <category term="Jvm" scheme="http://zhaojun.me/tags/Jvm/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB引擎下的锁模式</title>
    <link href="http://zhaojun.me/2017/08/18/InnoDB-lock/"/>
    <id>http://zhaojun.me/2017/08/18/InnoDB-lock/</id>
    <published>2017-08-18T06:13:35.000Z</published>
    <updated>2017-08-18T15:05:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>MySQL各存储引擎使用了三种类型（级别）的锁定机制：表级锁定，行级锁定和页级锁定。表级锁定顾名思义即是直接锁表，锁的颗粒度最大，实现简单，然后锁表带来的并发性会受到很大影响。行级锁定即锁的颗粒度很小，能够给予最大的并发性能，可能发生死锁。页级锁定位于两者之间，同样有可能发生死锁。InnoDB引擎即是使用行锁。另外对于不懂之处，可以开两个客户端，将事务设置为手动提交，修改事务隔离级别，进行实际测试。</p><h3 id="2、事务级别"><a href="#2、事务级别" class="headerlink" title="2、事务级别"></a>2、事务级别</h3><p>并发事务带来的问题：</p><ul><li>脏读：一个事务正在对一条记录修改，该事务未提交之前(commit)，其他事务读取了该修改后的，如果原事务回滚，则读取了脏数据</li><li>不可重复读：在一个事务里两次读取数据之间，有其他事务更新了原有数据，则一个事务里两次读取的数据会不一致</li><li>幻读： 在一个事务里两次读取数据之间，有其他事务插入了新的数据，则同一个事务里第二次读取数据会有新的数据</li></ul><p>其中不可重复读与幻读很相似，然而不可重复读主要是update和delete语句导致，即只要在第一次读取的记录上加锁即可，但是却无法防止insert插入记录。而幻读主要是insert语句导致两次记录数不同，需要在原来的记录和记录附近都加上锁。</p><p>sql定义了四种隔离级别：</p><ul><li>Read Uncommitted(读取未提交内容):级别最低，会有脏读、不可重复读、幻读等问题</li><li>Read Committed(读取提交内容):不会有脏读，但是会有不可重复读、幻读等问题</li><li>Repeatable Read(可重读):不会有脏读、不可重复读，但是会有幻读的问题</li><li>Serializable(可串行化): 最高级别，不会有以上问题，但是会导致大量的超时现象和锁竞争  </li></ul><p>当设置成不同的级别时，正是通过根据sql语句给记录(或者表)加上不同锁来实现</p><p>mysql的InnoDB引擎对以上四种级别重新定义：</p><ul><li>Read Uncommitted(读取未提交内容):跟上面一样</li><li>Read Committed(读取提交内容):针对当前读(见下文)，RC隔离级别保证对读取到的记录加锁(记录锁)，存在幻读现象，但是克服了不可重复读的问题</li><li>Repeatable Read(可重读):针对当前读(见下文)，RR隔离级别保证对读取到的记录加锁(记录锁)，同时保证对读取的范围加锁，新的满足查询条件的记录不能够插入(间隙锁)，不存在幻读现象。</li><li>Serializable(可串行化): 从MVCC并发控制退化为基于锁的并发控制。不区别快照读与当前读，所有的读操作均为当前读，读加读锁 (S锁)，写加写锁 (X锁)。，因此并发度急剧下降，在MySQL/InnoDB下不建议使用。</li></ul><h3 id="3、InnoDB的锁模式"><a href="#3、InnoDB的锁模式" class="headerlink" title="3、InnoDB的锁模式"></a>3、InnoDB的锁模式</h3><p>InnoDB实现了两种类型的行锁。</p><ul><li>共享锁(S)：允许一个事务去读一行，允许其他事务读，但是不能写</li><li>排他锁(X)： 允许一个事务去更新数据，但是不允许其他事务读也不能写</li></ul><p>除此两个行锁外，InnoDB还有两个表锁：</p><ul><li>意向共享锁(IS)：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁之前必须先取得该表的IS锁</li><li>意向排他锁(IX)：表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁</li></ul><p>InnoDB行锁模式兼容列表：</p><img src="/2017/08/18/InnoDB-lock/a.png" class="" title="图3-1"> <p>意向锁是InnoDB自动加的，不需要用户干预。如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。当然，如果一个事务的操作不需要锁，那直接操作即可。</p><h3 id="4、三级封锁协议"><a href="#4、三级封锁协议" class="headerlink" title="4、三级封锁协议"></a>4、三级封锁协议</h3><p>在运用X锁和S锁对数据对象加锁时，还需要约定一些规则 ，例如何时申请X锁或S锁、持锁时间、何时释放等。称这些规则为封锁协议（Locking Protocol）。对封锁方式规定不同的规则，就形成了各种不同的封锁协议。</p><h4 id="4-1、一级封锁协议"><a href="#4-1、一级封锁协议" class="headerlink" title="4.1、一级封锁协议"></a>4.1、一级封锁协议</h4><p>事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。一级封锁协议可以防止丢失修改，并保证事务T是可恢复的。使用一级封锁协议可以解决丢失修改问题。在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，它不能保证可重复读和不读“脏”数据。</p><h4 id="4-2、二级封锁协议"><a href="#4-2、二级封锁协议" class="headerlink" title="4.2、二级封锁协议"></a>4.2、二级封锁协议</h4><p>除了一级封锁协议外，还要加上事务T在读取数据R之前必须先对其加S锁，读完后方可释放S锁。二级封锁协议除防止了丢失修改，还可以进一步防止读“脏”数据。但在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。然而MySQL的InnoDB引擎不允许这种操作但不会拒绝查询操作(InnoDB引擎查询操作大部分不加锁)，而是查询数据被修改前的版本，这种机制被称为MVCC(多版本并发控制，见下文)。</p><h4 id="4-3、三级封锁协议"><a href="#4-3、三级封锁协议" class="headerlink" title="4.3、三级封锁协议"></a>4.3、三级封锁协议</h4><p>除了一级封锁协议外，还要加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。三级封锁协议除防止了丢失修改和不读“脏”数据外，还进一步防止了不可重复读。</p><h3 id="5、MVCC-多版本并发控制"><a href="#5、MVCC-多版本并发控制" class="headerlink" title="5、MVCC(多版本并发控制)"></a>5、MVCC(多版本并发控制)</h3><p>MySQL的InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC。MVCC最大的好处即读不加锁，读写不冲突。因此极大的增加了系统的并发性能，这也是为什么现阶段，几乎所有的RDBMS，都支持了MVCC。</p><p>在MVCC并发控制中，读操作可以分成两类：快照读(snapshot read)与当前读(current read)。快照读，读取的是记录的可见版本(有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。以InnoDB引擎为例：</p><p>快照读：简单select，不加锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where ?;</span><br></pre></td></tr></table></figure><p>当前读：包括特殊读，插入、更新、删除操作，需要加锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from table where ? lock in share mode; 共享锁</span><br><span class="line">select * from table where ? for update;  排他锁</span><br><span class="line">insert into table values (…);   排他锁</span><br><span class="line">update table set ? where ?;     排他锁</span><br><span class="line">delete from table where ?;      排他锁</span><br></pre></td></tr></table></figure><p>其中插入、更新、删除等操作，都是先根据where条件选出一条记录，然后加锁，然后进行相应操作；再选择下一条，循环往复。当然过程中的加锁也是一条一条记录加锁，直接操作完毕解锁。所以他们均可归为当前读。</p><p>也许你会有疑问，既然简单select操作不加锁，那么当你select时，一个事务update(insert)了该记录会怎么样？因为select不加锁，所以不会排斥update(insert)的操作，答案是在该select的事务提交之前，都会读取update(insert)操作之前的记录。这就是MVCC的作用。</p><p>另外加锁的原则是二阶段锁(2PL)，就是锁操作分为两个阶段：加锁阶段和解锁极端，并且两阶段不相交。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">begin； &#x2F;&#x2F;开启事务</span><br><span class="line">inser into table();   &#x2F;&#x2F;开始加锁阶段，加上insert对应的锁</span><br><span class="line">update table ...;     &#x2F;&#x2F;加上update对应的锁</span><br><span class="line">delete from ... where ...; &#x2F;&#x2F;加上delete对应的锁</span><br><span class="line">commit;              &#x2F;&#x2F;提交事务。开始解锁，同时释放三个操作加上的锁</span><br></pre></td></tr></table></figure><h3 id="6、InnoDB行锁实现方式"><a href="#6、InnoDB行锁实现方式" class="headerlink" title="6、InnoDB行锁实现方式"></a>6、InnoDB行锁实现方式</h3><h4 id="6-1、行锁"><a href="#6-1、行锁" class="headerlink" title="6.1、行锁"></a>6.1、行锁</h4><p>InnoDB的行锁是通过给索引项加锁实现的，如果没有索引，InnoDB会通过隐藏的聚簇索引来加锁。也就是说，如果不用过索引条件检索数据，那么InnoDB会给表中所有数据加锁，跟表锁是一样的。</p><ul><li>在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。</li><li>由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。</li><li>当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。</li><li>即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。</li></ul><h4 id="6-2、间隙锁（Next-Key锁）"><a href="#6-2、间隙锁（Next-Key锁）" class="headerlink" title="6.2、间隙锁（Next-Key锁）"></a>6.2、间隙锁（Next-Key锁）</h4><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。<br>例：<br>假如emp表中只有101条记录，其empid的值分别是 1,2,…,100,101，下面的SQL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where empid &gt; 100 for update;</span><br></pre></td></tr></table></figure><p>是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。</p><h3 id="7、乐观锁与悲观锁"><a href="#7、乐观锁与悲观锁" class="headerlink" title="7、乐观锁与悲观锁"></a>7、乐观锁与悲观锁</h3><p>乐观锁与悲观锁是两种统称，具体的实现就是上面锁的实现，比如乐观锁假定不会有并发问题，即上面的快照读，默认不加锁。悲观锁即假定有并发问题，即上面的共享锁，排他锁。</p><h3 id="8、示例"><a href="#8、示例" class="headerlink" title="8、示例"></a>8、示例</h3><p>讨论执行<code>delete from t1 where id = 10;</code>语句时的加锁状况。</p><ol><li><p>id是主键，Read Committed隔离级别：在id为10的索引上加X锁</p></li><li><p>id唯一索引,RC隔离级别：此组合中，id是unique索引，假如主键是name列。此时，加锁的情况由于组合一有所不同。由于id是unique索引，因此delete语句会选择走id列的索引进行where条件的过滤，在找到id=10的记录后，首先会将unique索引上的id=10索引记录加上X锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name = ‘d’ 对应的主键索引项加X锁。为什么聚簇索引上的记录也要加锁？试想一下，如果并发的一个SQL，是通过主键索引来更新：update t1 set id = 100 where name = ‘d’; 此时，如果delete语句没有将主键索引上的记录加锁，那么并发的update就会感知不到delete语句的存在，违背了同一记录上的更新/删除需要串行执行的约束。<br>结论：若id列是unique列，其上有unique索引。那么SQL需要加两个X锁，一个对应于id unique索引上的id = 10的记录，另一把锁对应于聚簇索引上的[name=’d’,id=10]的记录。</p></li><li><p>id非唯一索引,RC：<br>首先，id列索引上，满足id = 10查询条件的记录，均已加锁。同时，这些记录对应的主键索引上的记录也都加上了锁。与组合二唯一的区别在于，组合二最多只有一个满足等值查询的记录，而组合三会将所有满足查询条件的记录都加锁。<br>结论：若id列上有非唯一索引，那么对应的所有满足SQL查询条件的记录，都会被加锁。同时，这些记录在主键索引上的记录，也会被加锁。</p></li><li><p>id无索引,RC：若id列上没有索引，SQL会走聚簇索引的全扫描进行过滤，因此每条记录，无论是否满足条件，都会被加上X锁。但是，为了效率考量，MySQL做了优化，对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的加锁/放锁动作不会省略。同时，优化也违背了2PL的约束。</p></li><li><p>id主键，Repeatable Read隔离级别：在id为10的索引上加X锁</p></li><li><p>id唯一索引，Repeatable Read：两个X锁，id唯一索引满足条件的记录上一个，对应的聚簇索引上的记录一个。</p></li><li><p>id非唯一索引，Repeatable Read：id列上有一个非唯一索引，对应SQL：delete from t1 where id = 10; 首先，通过id索引定位到第一条满足查询条件的记录，加记录上的X锁，加GAP上的GAP锁(间隙锁，防止幻读)，然后加主键聚簇索引上的记录X锁，然后返回；然后读取下一条，重复进行。直至进行到第一条不满足条件的记录[11,f]，此时，不需要加记录X锁，但是仍旧需要加GAP锁，最后返回结束。</p></li><li><p>id无索引，Repeatable Read：在Repeatable Read隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有GAP，杜绝所有的并发 更新/删除/插入 操作。当然，也可以通过触发semi-consistent read，来缓解加锁开销与并发影响，但是semi-consistent read本身也会带来其他问题，不建议使用。</p></li></ol><p>参考资料：<br><a href="http://www.cnblogs.com/metoy/p/5545580.html">Mysql加锁过程详解</a></p>]]></content>
    
    
    <summary type="html">理解数据库锁机制可以在并发的时候选择更好的处理方式</summary>
    
    
    
    <category term="数据库" scheme="http://zhaojun.me/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://zhaojun.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>slf4j+Log4J2基础配置</title>
    <link href="http://zhaojun.me/2017/08/07/Log4J2/"/>
    <id>http://zhaojun.me/2017/08/07/Log4J2/</id>
    <published>2017-08-07T09:39:14.000Z</published>
    <updated>2017-08-18T14:36:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、slf4j简介："><a href="#1、slf4j简介：" class="headerlink" title="1、slf4j简介："></a>1、slf4j简介：</h3><p>slf4j是一种通用的“接口”，各种日志框架实现该接口，类似于jdbc的形式。有了这个统一的接口，日志实现框架切换起来就很方便，也就是解耦。</p><h3 id="2、maven依赖"><a href="#2、maven依赖" class="headerlink" title="2、maven依赖"></a>2、maven依赖</h3><p>java中使用slf4j+Log4J2需要引入以下两个依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.logging.log4j&lt;&#x2F;groupId&gt;  &#x2F;&#x2F;接口</span><br><span class="line">    &lt;artifactId&gt;log4j-slf4j-impl&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.logging.log4j&lt;&#x2F;groupId&gt;   &#x2F;&#x2F;核心实现</span><br><span class="line">    &lt;artifactId&gt;log4j-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&#x2F;&#x2F;当你需要切换日志框架时，直接切换jar就行了，当然你的代码应该使用slf4j所提供的通用的接口方法</span><br></pre></td></tr></table></figure><h3 id="3、Log4J2基础"><a href="#3、Log4J2基础" class="headerlink" title="3、Log4J2基础"></a>3、Log4J2基础</h3><p>Log4j 2的配置可以通过以下4种方式之一完成：</p><ul><li>通过使用XML，JSON，YAML或属性格式编写的配置文件。</li><li>以编程方式，通过创建一个ConfigurationFactory和配置实现。</li><li>以编程方式，通过调用配置界面中公开的API将组件添加到默认配置。</li><li>通过编程方式，通过调用内部Logger类的方法。</li></ul><p>Log4j将检查“log4j.configurationFile”系统属性，如果设置，将尝试使用与文件扩展名匹配的ConfigurationFactory加载配置。web项目可以在web.xml中设置Log4J2配置文件的位置，没有设置就默认要在根路劲下</p><ul><li>如果没有设置系统属性，则属性ConfigurationFactory将在类路径中查找log4j2-test.properties。</li><li>如果没有找到这样的文件，YAML ConfigurationFactory将在类路径中查找log4j2-test.yaml或log4j2-test.yml。</li><li>如果没有找到这样的文件，JSON ConfigurationFactory将在类路径中查找log4j2-test.json或log4j2-test.jsn。</li><li>如果没有找到这样的文件，XML ConfigurationFactory将在类路径中查找log4j2-test.xml。</li><li>如果找不到测试文件，则属性ConfigurationFactory将在类路径中查找log4j2.properties。</li><li>如果无法找到属性文件，则YAML ConfigurationFactory将在类路径上查找log4j2.yaml或log4j2.yml。</li><li>如果无法找到YAML文件，则JSON ConfigurationFactory将在类路径上查找log4j2.json或log4j2.jsn。</li><li>如果无法找到JSON文件，则XML ConfigurationFactory将尝试在类路径上找到log4j2.xml。</li><li>如果没有找到配置文件，将使用DefaultConfiguration。这将导致日志输出转到控制台。</li></ul><p>如果没有配置任何配置文件，默认配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;Configuration status&#x3D;&quot;WARN&quot;&gt;</span><br><span class="line">  &lt;Appenders&gt;</span><br><span class="line">    &lt;Console name&#x3D;&quot;Console&quot; target&#x3D;&quot;SYSTEM_OUT&quot;&gt; &#x2F;&#x2F;直接控制台输出</span><br><span class="line">      &lt;PatternLayout pattern&#x3D;&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;Console&gt;</span><br><span class="line">  &lt;&#x2F;Appenders&gt;</span><br><span class="line">  &lt;Loggers&gt;</span><br><span class="line">    &lt;Root level&#x3D;&quot;error&quot;&gt;  &#x2F;&#x2F;默认级别为error</span><br><span class="line">      &lt;AppenderRef ref&#x3D;&quot;Console&quot;&#x2F;&gt; &#x2F;&#x2F;指向Appenders中的console</span><br><span class="line">    &lt;&#x2F;Root&gt;</span><br><span class="line">  &lt;&#x2F;Loggers&gt;</span><br><span class="line">&lt;&#x2F;Configuration&gt;</span><br></pre></td></tr></table></figure><p>详细的配置可以去官网看：<a href="http://logging.apache.org/log4j/2.x/manual/configuration.html">详细配置</a></p><h3 id="4、示例"><a href="#4、示例" class="headerlink" title="4、示例"></a>4、示例</h3><p>java调用代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Log4jTest &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;LoggerFactory为slf4j类里的方法，获取org.slf4j.Logger接口在Log4J2中的实现</span><br><span class="line">    private static Logger logger &#x3D; LoggerFactory.getLogger(Log4jTest.class);</span><br><span class="line"></span><br><span class="line">    public static void main(final String... args) &#123;</span><br><span class="line">        logger.trace(&quot;trace&quot;);&#x2F;&#x2F;trace是Log4J2新增的级别，低于debug级别</span><br><span class="line">        logger.error(&quot;error&quot;);</span><br><span class="line">         &#x2F;&#x2F;将参数2替代&#123;&#125;进行输出，是使用slf4j+Log4J2的优势之一</span><br><span class="line">        logger.error(&quot;Exiting application.&#123;&#125;&quot; , 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用配置示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;Configuration&gt;</span><br><span class="line">    &lt;Appenders&gt;&lt;!-- 配置输出地点 --&gt;</span><br><span class="line">        &lt;!-- fileName输出路径，绝对路径 --&gt;</span><br><span class="line">        &lt;!-- 初始日志名称是error.log，一天之后，将rolling.log修改为error-日期.log并压缩为error-日期.log.gz(如error-20170806.log.gz，2017年8月6号)，rolling.log重新开始写； --&gt;</span><br><span class="line">        &lt;RollingFile name&#x3D;&quot;error-appender&quot; fileName&#x3D;&quot;&#x2F;home&#x2F;ubuntu&#x2F;data&#x2F;log&#x2F;installment&#x2F;error.log&quot; filePattern&#x3D;&quot;&#x2F;home&#x2F;ubuntu&#x2F;data&#x2F;log&#x2F;installment&#x2F;error-%d&#123;yyyyMMdd&#125;.log.gz&quot;&gt;</span><br><span class="line">            &lt;PatternLayout&gt;</span><br><span class="line">                &lt;Pattern&gt;%d&#123;MMdd HH:mm:ss.SSS&#125; %-5p [%c][%t] %m%n&lt;&#x2F;Pattern&gt;</span><br><span class="line">            &lt;&#x2F;PatternLayout&gt;</span><br><span class="line">            &lt;!-- 上面的filePattern后的日期格式，以及TimeBasedTriggeringPolicy的interval，日期格式精确到哪一位，interval也精确到哪一个单位 --&gt;</span><br><span class="line">            &lt;Policies&gt;</span><br><span class="line">                &lt;!-- 每天一次，即上面重写并压缩日志的频率，如果要根据文件大小来压缩使用SizeBasedTriggeringPolicy属性。modulate为true代表从始终0点开始计时--&gt;</span><br><span class="line">                &lt;TimeBasedTriggeringPolicy interval&#x3D;&quot;1&quot; modulate&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;Policies&gt;</span><br><span class="line">        &lt;&#x2F;RollingFile&gt;</span><br><span class="line">        &lt;RollingFile name&#x3D;&quot;debug-appender&quot; fileName&#x3D;&quot;&#x2F;home&#x2F;ubuntu&#x2F;data&#x2F;log&#x2F;installment&#x2F;debug.log&quot; filePattern&#x3D;&quot;&#x2F;home&#x2F;ubuntu&#x2F;data&#x2F;log&#x2F;installment&#x2F;debug-%d&#123;yyyyMMdd&#125;.log.gz&quot;&gt;</span><br><span class="line">            &lt;PatternLayout&gt;</span><br><span class="line">                &lt;Pattern&gt;%d&#123;MMdd HH:mm:ss.SSS&#125; %-5p [%c][%t] %m%n&lt;&#x2F;Pattern&gt;&lt;!-- 定义日志输出的样式--&gt;</span><br><span class="line">            &lt;&#x2F;PatternLayout&gt;</span><br><span class="line">            &lt;Policies&gt;</span><br><span class="line">                &lt;TimeBasedTriggeringPolicy interval&#x3D;&quot;1&quot; modulate&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;Policies&gt;</span><br><span class="line">            &lt;!-- Filters代表过滤掉传来的日志  --&gt;</span><br><span class="line">            &lt;Filters&gt;</span><br><span class="line">                &lt;ThresholdFilter level&#x3D;&quot;warn&quot; onMatch&#x3D;&quot;DENY&quot; onMismatch&#x3D;&quot;NEUTRAL&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;Filters&gt;</span><br><span class="line">        &lt;&#x2F;RollingFile&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;RollingFile name&#x3D;&quot;request-appender&quot; fileName&#x3D;&quot;&#x2F;home&#x2F;ubuntu&#x2F;data&#x2F;log&#x2F;installment&#x2F;request.log&quot; filePattern&#x3D;&quot;&#x2F;home&#x2F;ubuntu&#x2F;data&#x2F;log&#x2F;installment&#x2F;request-%d&#123;yyyyMMdd&#125;.log.gz&quot;&gt;</span><br><span class="line">            &lt;PatternLayout&gt;</span><br><span class="line">                &lt;Pattern&gt;%d&#123;MMdd HH:mm:ss.SSS&#125; %m%n&lt;&#x2F;Pattern&gt;</span><br><span class="line">            &lt;&#x2F;PatternLayout&gt;</span><br><span class="line">            &lt;Policies&gt;</span><br><span class="line">                &lt;TimeBasedTriggeringPolicy interval&#x3D;&quot;1&quot; modulate&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;Policies&gt;</span><br><span class="line">        &lt;&#x2F;RollingFile&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 发送到邮箱，基于smtp协议 --&gt;</span><br><span class="line">        &lt;SMTP name&#x3D;&quot;Mailer&quot; subject&#x3D;&quot;testErrorLog&quot; to&#x3D;&quot;zhaojun@qq.com, zhaojun@163.com from&#x3D;&quot;no-reply@qq.com&quot; smtpHost&#x3D;&quot;localhost&quot; smtpProtocol&#x3D;&quot;smtp&quot; smtpUsername&#x3D;&quot;anonymous&quot; smtpPassword&#x3D;&quot;anonymous&quot;  smtpPort&#x3D;&quot;25&quot; ignoreExceptions&#x3D;&quot;false&quot;&gt;</span><br><span class="line">            &lt;PatternLayout&gt;</span><br><span class="line">                &lt;Pattern&gt;%m%n%d&#123;MMdd HH:mm:ss.SSS&#125; %-5p [%c][%t]&lt;&#x2F;Pattern&gt;</span><br><span class="line">            &lt;&#x2F;PatternLayout&gt;</span><br><span class="line">        &lt;&#x2F;SMTP&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- FailoverAppender　维护一个队列，系统将尝试向队列中的Appender依次输出LogEvent，直到有一个成功为止，这里向邮箱发送邮件，如果发送失败，就再发 --&gt;</span><br><span class="line">        &lt;Failover name&#x3D;&quot;Failover&quot; primary&#x3D;&quot;Mailer&quot;&gt;</span><br><span class="line">            &lt;Failovers&gt;</span><br><span class="line">                &lt;AppenderRef ref&#x3D;&quot;Mailer&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;Failovers&gt;</span><br><span class="line">        &lt;&#x2F;Failover&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--&lt;Raven name&#x3D;&quot;Sentry&quot;&gt;  Sentry使用，需要引入新的jar包</span><br><span class="line">            &lt;dsn&gt;&lt;&#x2F;dsn&gt;</span><br><span class="line">            &lt;environment&gt;&lt;&#x2F;environment&gt;</span><br><span class="line">            &lt;servername&gt;&lt;&#x2F;servername&gt;</span><br><span class="line">        &lt;&#x2F;Raven&gt;--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;Appenders&gt;&lt;!--  除了RollingFileAppender、SMTPAppender、FailoverAppender，还有许多其他的Appender，见上述官网配置链接--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Loggers&gt;</span><br><span class="line">        &lt;!--AsyncLogger中的level代表输出的日志的级别，大于等于才能输出。仅对com.test包下的类有效。additivity为false表示不继承父类，否则会输出两次一样的日志，includeLocation包含类的位置--&gt;</span><br><span class="line">        &lt;AsyncLogger name&#x3D;&quot;com.test&quot; additivity&#x3D;&quot;false&quot; level&#x3D;&quot;DEBUG&quot; includeLocation&#x3D;&quot;true&quot;&gt;</span><br><span class="line">            &lt;appenderRef ref&#x3D;&quot;debug-appender&quot; level&#x3D;&quot;debug&quot;&#x2F;&gt;&lt;!--大于等于debug的调用debug-appender输出--&gt;</span><br><span class="line">            &lt;AppenderRef ref&#x3D;&quot;error-appender&quot; level&#x3D;&quot;error&quot;&#x2F;&gt;&lt;!--大于等于error的调用error-appender输出--&gt;</span><br><span class="line">            &lt;AppenderRef ref&#x3D;&quot;Sentry&quot; level&#x3D;&quot;error&quot;&#x2F;&gt;&lt;!--大于等于error的调用Sentry输出--&gt;</span><br><span class="line">        &lt;&#x2F;AsyncLogger&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--request请求输出--&gt;</span><br><span class="line">        &lt;AsyncLogger name&#x3D;&quot;request&quot; additivity&#x3D;&quot;false&quot; level&#x3D;&quot;info&quot; includeLocation&#x3D;&quot;true&quot;&gt;</span><br><span class="line">            &lt;appenderRef ref&#x3D;&quot;request-appender&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;AsyncLogger&gt;</span><br><span class="line">    &lt;&#x2F;Loggers&gt;</span><br><span class="line">&lt;&#x2F;Configuration&gt;                                                                                                                                                                                     </span><br></pre></td></tr></table></figure><p>其中，使用AsyncLogger异步logger需要引入新的jar包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.lmax&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;disruptor&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>另外在以上配置中，Filters即过滤器，决定日志事件能否被输出。过滤条件有三个值：ACCEPT(接受), DENY(拒绝) or NEUTRAL(中立).</p><p>在使用单个过滤器的时候，一般直接使用ACCEPT或DENY。但是在组合过滤器中，如果用接受ACCEPT的话，日志信息就会直接写入日志文件,后续的过滤器不再进行过滤。所以，在组合过滤器中，接受使用NEUTRAL（中立），被第一个过滤器接受的日志信息，会继续用后面的过滤器进行过滤，只有符合所有过滤器条件的日志信息，才会被最终写入日志文件。</p><p>ThresholdFilter有几个参数：</p><ul><li>level：将被过滤的级别。</li><li>onMatch:默认值是NEUTRAL</li><li>onMismatch：默认是DENY</li></ul><p>如果LogEvent中的LogLevel大于ThresholdFilter中配置的LogLevel，那么返回onMatch的值，否则返回onMismatch的值，例如:如果ThresholdFilter配置的LogLevel是ERROR，LogEvent的LogLevel是DEBUG。那么onMismatch的值将被返回，因为ERROR小于DEBUG。如果是Accept，将自己被接受，而不经过下一个过滤器。</p><p>下面的例子可以这样理解：如果是INFO级别及其以上，将经过通过第一个过滤，进入第二个，否则使用onMismatch：拒绝进入。对于第二个，如果是大于等于WARN(WARN/ERROR)，那么将返回onMatch，也就是拒绝，如果是其他情况(也就是INFO)，将是中立情况，因为后面没有其他过滤器，则被接受。最后的结果就只剩下INFO级别的日志。也就符合了RollingFileInfo只记录Info级别的规则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;RollingFile name&#x3D;&quot;RollingFileInfo&quot; fileName&#x3D;&quot;&quot; filePattern&#x3D;&quot;&quot;&gt;</span><br><span class="line">    &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;        </span><br><span class="line">    &lt;Filters&gt;</span><br><span class="line">        &lt;ThresholdFilter level&#x3D;&quot;INFO&quot;&#x2F;&gt;</span><br><span class="line">        &lt;ThresholdFilter level&#x3D;&quot;WARN&quot; onMatch&#x3D;&quot;DENY&quot; onMismatch&#x3D;&quot;NEUTRAL&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;Filters&gt;</span><br><span class="line">    &lt;PatternLayout pattern&#x3D;&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;RollingFile&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Log4J2基础配置</summary>
    
    
    
    <category term="日志" scheme="http://zhaojun.me/categories/%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="日志" scheme="http://zhaojun.me/tags/%E6%97%A5%E5%BF%97/"/>
    
    <category term="Log4J2" scheme="http://zhaojun.me/tags/Log4J2/"/>
    
  </entry>
  
  <entry>
    <title>Asterisk</title>
    <link href="http://zhaojun.me/2017/08/04/Asterisk/"/>
    <id>http://zhaojun.me/2017/08/04/Asterisk/</id>
    <published>2017-08-04T06:13:35.000Z</published>
    <updated>2017-11-01T11:59:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>Asterisk是一个支持多种协议的通话软件，因为网上资料很少，所以大部分都来源于官网的文档。很多都要对着文档一点点摸索。<br><a href="https://wiki.asterisk.org/wiki/display/AST/Home">Asterisk学习</a></p><h3 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h3><p>上述链接中有对应的安装步骤，由于我用的是ubuntu系统，所以只记录一下ubuntu的安装步骤：</p><p>注意：建议在安装之前使用命令<code>sudo apt-get install libcurl4-openssl-dev</code>,然后可以在命令行调用curl命令试试，这样安装asterisk软件之后可以在配置文件中使用curl命令发起http请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo wget 下载链接 </span><br><span class="line">tar -zxvf 文件名 </span><br><span class="line">cd dahdi-linux-complete-2.X.Y+2.X.Y</span><br><span class="line">sudo .&#x2F;configure --prefix&#x3D;绝对路径（安装的目录）</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br><span class="line">sudo make samples （生成默认配置文件）</span><br><span class="line">sudo make config   (在ubuntu里生成启动脚本，如&#x2F;etc&#x2F;init.d&#x2F;目录下的启动文件)</span><br><span class="line">sudo make install-logrotate （生成日志文件）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>安装的时候注意提示，缺的包就对应去安装，安装成功会有相应的提示，就可以进行下一步。</p><h3 id="3、基础命令"><a href="#3、基础命令" class="headerlink" title="3、基础命令"></a>3、基础命令</h3><p>启动：<br><code>sudo /etc/init.d/asterisk start</code><br>重启：<br><code>sudo /etc/init.d/asterisk restart</code><br>停止：<br><code>sudo /etc/init.d/asterisk stop</code><br>查看状态：<br><code>sudo /etc/init.d/asterisk status</code><br>启动之后可以调用以下命令进入控制台：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo .&#x2F;..&#x2F;..&#x2F;sbin&#x2F;asterisk -r</span><br><span class="line">sudo .&#x2F;asterisk -r</span><br><span class="line">就是进入软件安装的目录里的sbin目录之后，带上r参数运行里面的asterisk文件来进入控制台。可以在控制台里操作asterisk。</span><br><span class="line">另外，必须要用以上命令启动了才能进入控制台，不然会报错。</span><br><span class="line">例如：</span><br><span class="line">sip show peers （查看你配置了多少个客户端）</span><br></pre></td></tr></table></figure><p>进入控制台以后，你还可以根据自己的操作来实时查看输出的日志(非常重要)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">进入debug模式：</span><br><span class="line">core set verbose 5</span><br><span class="line">core set debug 5</span><br><span class="line">module reload logger</span><br></pre></td></tr></table></figure><p>另外，asterisk的日志文件在安装目录里面的/var/log/asterisk目录下的messages文件里</p><h3 id="4、基础配置"><a href="#4、基础配置" class="headerlink" title="4、基础配置"></a>4、基础配置</h3><p>版本号为版本为asterisk-14.6.0，其余大同小异。</p><p>配置文件都在安装目录里的<code>etc/asterisk</code>目录下，当安装时使用<code>sudo make samples</code>命令后会生成一堆默认的配置文件，我们只需修改其中三个sip.conf,pjsip.conf,extensions.conf。</p><p>其中sip.conf配置asterisk的对等机，asterisk使用通道(channel)来与客户端相连，一个客户端对发起一个呼叫，asterisk就会建立在彼此之间建立一个通道。建立通道的协议有很多种，sip比较常用，所以直接在sip.conf上配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sip.conf:</span><br><span class="line">[general]    ;通用的</span><br><span class="line">context&#x3D;default</span><br><span class="line"></span><br><span class="line">[1001]       ;配置一个1001账户，新增账户直接复制1001的账户配置即可   </span><br><span class="line">type&#x3D;friend</span><br><span class="line">context&#x3D;from-internal</span><br><span class="line">host&#x3D;dynamic</span><br><span class="line">secret&#x3D;123</span><br><span class="line">disallow&#x3D;all</span><br><span class="line">allow&#x3D;ulaw</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户机就能使用账号1001，密码为123的账户了。</p><p>pjsip.conf配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[transport-udp]</span><br><span class="line">type&#x3D;transport</span><br><span class="line">protocol&#x3D;udp     ;通信协议为udp</span><br><span class="line">bind&#x3D;0.0.0.0     ;支持多个网卡，只有一个网卡也可以配置127.0.0.1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>extensions.conf配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[from-internal]  ;对应sip.conf里的context&#x3D;from-internal，类似web里的context，上下文</span><br><span class="line">exten &#x3D; 150,1,Answer() ;from-internal里配置的任何账号拨打150时都会被响应</span><br><span class="line">same &#x3D; n,Wait(1)       ;然后等待一秒</span><br><span class="line">same &#x3D; n,UserEvent(Test,Note: I am calling now $&#123;DIALSTATUS&#125;.) ;发送UserEvent事件，测试时这一步可以不要。</span><br><span class="line">;播放安装目录下的&#x2F;var&#x2F;lib&#x2F;asterisk&#x2F;sounds&#x2F;en中的hello-world，大概就两秒，很快过去，而且有的手机听不到声音。可以相对路径，可以绝对路径</span><br><span class="line">same &#x3D; n,Playback(hello-world) </span><br><span class="line">same &#x3D; n,Hangup()  ;挂断</span><br><span class="line"></span><br><span class="line">;拨打120响应，日志输出级别ERROR，输出传来的phonenumber参数，按照前文，控制台能看到</span><br><span class="line">exten &#x3D; 120,1,Log(ERROR, $&#123;phonenumber&#125;) </span><br><span class="line">;拨打SIP&#x2F;1001，即sip.conf里的1001账户，15秒内没打通就挂断，一旦接听就跳到sCONNECTED标签处。没配置就只能挂断时才会执行下一步</span><br><span class="line">;Dial应用有很多参数，需要相应的功能可以去官网搜一下</span><br><span class="line">same &#x3D; n,Dial(SIP&#x2F;1001,15,G(sCONNECTED)) </span><br><span class="line">same &#x3D; n,Log(ERROR,aaaaaaaaaa  $&#123;DIALSTATUS&#125;) ;没打通就跳到这里，$&#123;DIALSTATUS&#125;为打电话状态</span><br><span class="line">;使用curl发起http请求，需要按照前文中安装需要的工具才能使用。NoOp命令不做操作。不把curl放在NoOp中，好像没法使用，没摸索出来。</span><br><span class="line">same &#x3D; n,NoOp($&#123;CURL(http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;call&#x2F;api&#x2F;dialstatus.do?dialResult&#x3D;$&#123;DIALSTATUS&#125;)&#125;)</span><br><span class="line">same &#x3D; n,Hangup()  ;挂断，不然会继续往后执行</span><br><span class="line">same &#x3D; n(sCONNECTED),Log(ERROR,bbbbbbbb  $&#123;DIALSTATUS&#125;)</span><br><span class="line">same &#x3D; n,Gotoif($&#123;DIALSTATUS&#125;&#x3D;&#x3D;ANSWER?aANSWER:aEND)  ;根据状态来进行不同的跳转</span><br><span class="line">same &#x3D; n(aEND),Log(ERROR, ccccccccccc  $&#123;DIALSTATUS&#125;)</span><br><span class="line">same &#x3D; n,Hangup()</span><br><span class="line">same &#x3D; n(aANSWER),Log(ERROR, ddddddd  $&#123;DIALSTATUS&#125;)</span><br><span class="line">same &#x3D; n,NoOp($&#123;CURL(http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;call&#x2F;api&#x2F;dialstatus.do?dialResult&#x3D;$&#123;DIALSTATUS&#125;)&#125;)</span><br><span class="line">same &#x3D; n,Hangup()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>按照这样的配置后，可以使用使用手机安装支持sip通话的软件，比如Linphone,Zoiper等等，电脑上也有很多sip软件。进行相应配置后，拨打150，asterisk会充当服务器接听电话。按照extensions.conf中的配置进行执行步骤。你也可以配置多个账户，拨打120，这样asterisk会建立与你的通道，然后再建立与1001账户的通道，两个通道之间就能通话了。</p><h3 id="5、自动拨打电话"><a href="#5、自动拨打电话" class="headerlink" title="5、自动拨打电话"></a>5、自动拨打电话</h3><p>asterisk提供agi、ami、ari三种方式供程序调用，ari我也没用过，agi、amid的java教程如下,其余语言也有对应的教程：<br><a href="https://asterisk-java.org/tutorial/">示例</a><br>ami使用如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">需要先配置manager.conf</span><br><span class="line">[general]</span><br><span class="line">enabled &#x3D; yes</span><br><span class="line">webenabled &#x3D; yes</span><br><span class="line"></span><br><span class="line">port &#x3D; 5038</span><br><span class="line">bindaddr &#x3D; 0.0.0.0</span><br><span class="line"></span><br><span class="line">[manager]</span><br><span class="line">secret&#x3D;123456</span><br><span class="line">permit&#x3D;0.0.0.0&#x2F;0.0.0.0</span><br><span class="line">read&#x3D;all</span><br><span class="line">write&#x3D;all</span><br><span class="line"></span><br><span class="line">登录：</span><br><span class="line">private static ManagerConnection managerConnection;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        if (managerConnection &#x3D;&#x3D; null) &#123;</span><br><span class="line">            ManagerConnectionFactory factory &#x3D; new ManagerConnectionFactory(</span><br><span class="line">                    &quot;127.0.0.1&quot;, &quot;manager&quot;, &quot;123456&quot;);</span><br><span class="line"></span><br><span class="line">            managerConnection &#x3D; factory.createManagerConnection();</span><br><span class="line">            managerConnection.addEventListener(new DialEventListener());&#x2F;&#x2F;增加监听事件</span><br><span class="line">            try &#123;</span><br><span class="line">                managerConnection.login();&#x2F;&#x2F;登录</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (AuthenticationFailedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (TimeoutException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>拨打电话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">OriginateAction originateAction;</span><br><span class="line">        ManagerResponse originateResponse &#x3D; null;</span><br><span class="line"></span><br><span class="line">        originateAction &#x3D; new OriginateAction();</span><br><span class="line">        originateAction.setChannel(&quot;SIP&#x2F;1004&quot;);先建立与SIP&#x2F;1004的通道</span><br><span class="line">        originateAction.setContext(&quot;from-internal&quot;);&#x2F;&#x2F;上下文</span><br><span class="line">        originateAction.setExten(&quot;130&quot;);&#x2F;&#x2F;拨打130。需要SIP&#x2F;1004接通才进行拨打</span><br><span class="line">        originateAction.setPriority(1);&#x2F;&#x2F;从1开始</span><br><span class="line">        originateAction.setAsync(false); </span><br><span class="line">        originateAction.setTimeout(30000l);</span><br><span class="line">        originateAction.setVariable(&quot;phonenumber&quot;,&quot;123344444&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;managerConnection.login();</span><br><span class="line">            originateResponse &#x3D; managerConnection.sendAction(originateAction, 3000);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            response.getWriter().write();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">           &#x2F;&#x2F; managerConnection.logoff();登出</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>监听：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class DialEventListener implements ManagerEventListener &#123; &#x2F;&#x2F;继承该接口</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onManagerEvent(ManagerEvent event) &#123;</span><br><span class="line">        System.out.println(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于每次拨打电话时，都要先建立与SIP/1004的通道，即需要该用户手动接通电话，才会执行extension.conf里的配置，所以不能完全自动化，可以安装以下包来实现自动接听:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">libre</span><br><span class="line">librem</span><br><span class="line">openssl</span><br><span class="line">然后再安装baresip(基于以上三个包),github上均有，按照上面对应的方法进行安装即可</span><br></pre></td></tr></table></figure><p>安装后进入你自己的主文件夹里会有.baresip目录，进入后编辑accounts文件，配置账户：<br><code>&lt;sip:1004:123@127.0.0.1;transport=udp&gt;;answermode=auto  #协议:账号:密码@ip地址</code><br>这跟在前面用手机软件配置账户是一样的，不过它多了一个自动接通的功能，不用手动去接通。</p><p>ps：官方英文文档虽然难懂，却是入门的的途径；用英文进行谷歌搜索的结果真的比中文好。</p>]]></content>
    
    
    <summary type="html">Asterisk是一个自动拨打电话的软件,能够直接使用配置文件进行控制。</summary>
    
    
    
    <category term="Asterisk" scheme="http://zhaojun.me/categories/Asterisk/"/>
    
    
    <category term="Asterisk" scheme="http://zhaojun.me/tags/Asterisk/"/>
    
  </entry>
  
</feed>
